// Generated by CoffeeScript 2.6.0
// @fileoverview Implementation of Finger Tree, an immutable general-purpose
//   data structure which can further be used to implement random-access
//   sequences, priority-queues, ordered sequences, interval trees, etc.

//   Based on:
//   Ralf Hinze and Ross Paterson,
//   "Finger trees: a simple general-purpose data structure",
//   <http://www.soi.city.ac.uk/~ross/papers/FingerTree.html>
// @author Xueqiao Xu <xueqiaoxu@gmail.com>

// Converted to CoffeeScript by Bill Burdick, 2015
// I converted this for people like me who prefer to read the code, rather
// than generated docs.  With this in mind, I've condensed the code to make
// it easier to see more code at a time and removed doc generation-only
// information (like @inheritDoc comments).  Also, in the name of readability
// and brevity, I have removed many micro-optimizations (like caching this.*
// in a variable) because I think most VMs will handle these anyway.  Other
// than that, I've tried to preserve the original author's intent.

// MIT License

// ï¿½ 2014 Xueqiao Xu <xueqiaoxu@gmail.com>

// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
'use strict';
var Deep, DelayedFingerTree, Digit, Empty, Node, Single, Split, app3, append, deepLeft, deepRight, fromArray, makeNodeMeasurer, nodes, notImplemented, prepend;

// Placeholder for methods of interfaces / abstract base classes.
notImplemented = function() {
  throw new Error('Not Implemented');
};

// A split is a container which has 3 parts, in which the left part is the
// elements that do not satisfy the predicate, the middle part is the
// first element that satisfies the predicate and the last part is the rest
// elements.
Split = class Split {
  // @param {Array|FingerTree} left
  // @param {*} mid
  // @param {Array|FingerTree} right
  constructor(left1, mid1, right1) {
    this.left = left1;
    this.mid = mid1;
    this.right = right1;
  }

};

// A digit is a measured container of one to four elements.
// @constructor
// @param {Object.<string, function>} measurer
// @param {Array.<*>} items
Digit = class Digit {
  constructor(measurer1, items) {
    var item, j, len, m, ref;
    this.measurer = measurer1;
    this.items = items;
    this.length = this.items.length;
    m = this.measurer.identity();
    ref = this.items;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      m = this.measurer.sum(m, this.measurer.measure(item, this));
    }
    // @private
    this.measure_ = m;
  }

  // Get the measure of the digit.
  measure() {
    return this.measure_;
  }

  // Get the first element stored in the digit.
  peekFirst() {
    return this.items[0];
  }

  // Get the last element stored in the digit.
  peekLast() {
    return this.items[this.items.length - 1];
  }

  // Return a new digit with the first item removed.
  // @return {Digit}
  removeFirst() {
    return this.slice(1);
  }

  // Return a new digit with the first item removed.
  // @return {Digit}
  removeLast() {
    return this.slice(0, this.length - 1);
  }

  // Return a new digit with the items sliced.
  // @param {Number} start
  // @param {Number} end
  // @return {Digit}
  slice(start, end) {
    if (end == null) {
      end = this.length;
    }
    return new Digit(this.measurer, this.items.slice(start, end));
  }

  // Split the digit into 3 parts, in which the left part is the elements
  // that does not satisfy the predicate, the middle part is the first
  // element that satisfies the predicate and the last part is the rest
  // elements.
  // @param {Function} predicate A function which returns either true or false
  //   given each stored element.
  // @param {*} initial The initial measure for the predicate
  // @return {Split}
  split(predicate, initial) {
    var i, item, j, len, measure, ref;
    measure = initial;
    i = null;
    if (this.items.length === 1) {
      return new Split([], this.items[0], []);
    } else {
      ref = this.items;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        measure = this.measurer.sum(measure, this.measurer.measure(item));
        if (predicate(measure)) {
          break;
        }
      }
      return new Split(this.items.slice(0, i), item, this.items.slice(i + 1));
    }
  }

  // Return the JSON representation of the digit.
  toJSON() {
    return {
      type: 'digit',
      items: this.items,
      measure: this.measure()
    };
  }

};

// A node is a measured container of either 2 or 3 sub-finger-trees.
Node = class Node {
  // @param {Object.<string, function>} measurer
  // @param {Array.<FingerTree>} items
  constructor(measurer1, items) {
    var item, j, len, m, ref;
    this.measurer = measurer1;
    this.items = items;
    m = this.measurer.identity();
    ref = this.items;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      m = this.measurer.sum(m, this.measurer.measure(item));
    }
    // @private
    this.measure_ = m;
  }

  // Get the measure of the node.
  measure() {
    return this.measure_;
  }

  // Convert the node to a digit.
  // @return {Digit}
  toDigit() {
    return new Digit(this.measurer, this.items);
  }

  // Return the JSON representation of the node.
  toJSON() {
    return {
      type: 'node',
      items: this.items,
      measure: this.measure()
    };
  }

};

export var FingerTree = (function() {
  // Interface of finger-tree.
  // @interface
  class FingerTree {
    // Force on a normal FingerTree just returns this
    force() {
      return this;
    }

    // Take elements from the tree until the predicate returns true.
    // @param {function(*): boolean} predicate
    // @return {FingerTree}
    takeUntil(predicate) {
      return this.split(predicate)[0];
    }

    // Drop elements from the tree until the predicate returns true.
    // @param {function(*): boolean} predicate
    // @return {FingerTree}
    dropUntil(predicate) {
      return this.split(predicate)[1];
    }

    // iterate over the nodes
    each(func) {
      var results, t;
      t = this;
      results = [];
      while (!t.isEmpty()) {
        func(t.peekFirst());
        results.push(t = t.removeFirst());
      }
      return results;
    }

    // iterate over the nodes
    eachReverse(func) {
      var results, t;
      t = this;
      results = [];
      while (!t.isEmpty()) {
        func(t.peekLast());
        results.push(t = t.removeLast());
      }
      return results;
    }

    toArray() {
      var a;
      a = [];
      this.each(function(n) {
        return a.push(n);
      });
      return a;
    }

  };

  // Get the measure of the tree.
  FingerTree.measure = notImplemented;

  // Check whether the tree is empty.
  // @return {boolean} True if the tree is empty.
  FingerTree.prototype.isEmpty = notImplemented;

  // Return a new tree with an element added to the front.
  // @param {*} v The element to add.
  // @return {FingerTree}
  FingerTree.prototype.addFirst = notImplemented;

  // Return a new tree with an element added to the end.
  // @param {*} v The element to add.
  // @return {FingerTree} A new finger-tree with the element added.
  FingerTree.prototype.addLast = notImplemented;

  // Return a new tree with the first element removed.
  // @return {FingerTree}
  FingerTree.prototype.removeFirst = notImplemented;

  // Return a new tree with the last element removed.
  // @return {FingerTree}
  FingerTree.prototype.removeLast = notImplemented;

  // Get the first element of the tree.
  // @return {*}
  FingerTree.prototype.peekFirst = notImplemented;

  // Get the last element of the tree.
  // @return {*}
  FingerTree.prototype.peekLast = notImplemented;

  // Concatenate this tree with another tree.
  // @param {FingerTree} other
  // @return {FingerTree} The concatenated tree.
  FingerTree.prototype.concat = notImplemented;

  // Split the tree into two halves, where the first half is a finger-tree
  // which contains all the elements that satisfy the given predicate,
  // while the ones from the other half do not.
  // @param {function(*): boolean} predicate
  // @return {Array.<FingerTree>} An array with the first element being a
  //   finger-tree that contains all the satisfying elements and the second
  //   element being a finger-tree that contains all the other elements.
  FingerTree.prototype.split = notImplemented;

  // @return the JSON representation of the tree.
  FingerTree.prototype.toJSON = notImplemented;

  return FingerTree;

}).call(this);

// An empty finger-tree.
Empty = class Empty extends FingerTree {
  constructor(measurer1) {
    super();
    this.measurer = measurer1;
    this.measure_ = this.measurer.identity();
  }

  measure() {
    return this.measure_;
  }

  addFirst(v) {
    return new Single(this.measurer, v);
  }

  addLast(v) {
    return new Single(this.measurer, v);
  }

  peekFirst() {
    return null;
  }

  peekLast() {
    return null;
  }

  isEmpty() {
    return true;
  }

  concat(other) {
    return other;
  }

  split(predicate) {
    return [this, this];
  }

  toJSON() {
    return {
      type: 'empty',
      measure: this.measure()
    };
  }

};

// A finger-tree which contains exactly one element.
Single = class Single extends FingerTree {
  // @param {Object.<string, function>} measurer
  // @param {*} value
  constructor(measurer1, value) {
    super();
    this.measurer = measurer1;
    this.value = value;
    this.measure_ = this.measurer.measure(this.value);
  }

  measure() {
    return this.measure_;
  }

  addFirst(v) {
    return new Deep(this.measurer, new Digit(this.measurer, [v]), new Empty(makeNodeMeasurer(this.measurer)), new Digit(this.measurer, [this.value]));
  }

  addLast(v) {
    return new Deep(this.measurer, new Digit(this.measurer, [this.value]), new Empty(makeNodeMeasurer(this.measurer)), new Digit(this.measurer, [v]));
  }

  removeFirst() {
    return new Empty(this.measurer);
  }

  removeLast() {
    return new Empty(this.measurer);
  }

  peekFirst() {
    return this.value;
  }

  peekLast() {
    return this.value;
  }

  isEmpty() {
    return false;
  }

  concat(other) {
    return other.addFirst(this.value);
  }

  // Helper function to split the tree into 3 parts.
  // @private
  // @param {function(*): boolean} predicate
  // @param {*} initial The initial measurement for reducing
  // @return {Split}
  splitTree(predicate, initial) {
    return new Split(new Empty(this.measurer), this.value, new Empty(this.measurer));
  }

  split(predicate) {
    if (predicate(this.measure())) {
      return [new Empty(this.measurer), this];
    } else {
      return [this, new Empty(this.measurer)];
    }
  }

  toJSON() {
    return {
      type: 'single',
      value: this.value,
      measure: this.measure()
    };
  }

};

// A finger-tree which contains two or more elements.
Deep = class Deep extends FingerTree {
  // @param {Object.<string, function>} measurer
  // @param {Digit} left
  // @param {FingerTree} mid
  // @param {Digit} right
  constructor(measurer1, left1, mid1, right1) {
    super();
    this.measurer = measurer1;
    this.left = left1;
    this.mid = mid1;
    this.right = right1;
    this.measure_ = null;
  }

  measure() {
    if (this.measure_ === null) {
      this.measure_ = this.measurer.sum(this.measurer.sum(this.left.measure(), this.mid.measure()), this.right.measure());
    }
    return this.measure_;
  }

  addFirst(v) {
    var leftItems;
    leftItems = this.left.items;
    if (this.left.length === 4) {
      return new Deep(this.measurer, new Digit(this.measurer, [v, leftItems[0]]), this.mid.addFirst(new Node(this.measurer, [leftItems[1], leftItems[2], leftItems[3]])), this.right);
    } else {
      return new Deep(this.measurer, new Digit(this.measurer, [v].concat(leftItems)), this.mid, this.right);
    }
  }

  addLast(v) {
    var rightItems;
    rightItems = this.right.items;
    if (this.right.length === 4) {
      return new Deep(this.measurer, this.left, this.mid.addLast(new Node(this.measurer, [rightItems[0], rightItems[1], rightItems[2]])), new Digit(this.measurer, [rightItems[3], v]));
    } else {
      return new Deep(this.measurer, this.left, this.mid, new Digit(this.measurer, rightItems.concat([v])));
    }
  }

  removeFirst() {
    var newMid;
    if (this.left.length > 1) {
      return new Deep(this.measurer, this.left.removeFirst(), this.mid, this.right);
    } else if (!this.mid.isEmpty()) {
      newMid = new DelayedFingerTree(() => {
        return this.mid.removeFirst();
      });
      return new Deep(this.measurer, this.mid.peekFirst().toDigit(), newMid, this.right);
    } else if (this.right.length === 1) {
      return new Single(this.measurer, this.right.items[0]);
    } else {
      return new Deep(this.measurer, this.right.slice(0, 1), this.mid, this.right.slice(1));
    }
  }

  removeLast() {
    var newMid;
    if (this.right.length > 1) {
      return new Deep(this.measurer, this.left, this.mid, this.right.removeLast());
    } else if (!this.mid.isEmpty()) {
      newMid = new DelayedFingerTree(() => {
        return this.mid.removeLast();
      });
      return new Deep(this.measurer, this.left, newMid, this.mid.peekLast().toDigit());
    } else if (this.left.length === 1) {
      return new Single(this.measurer, this.left.items[0]);
    } else {
      return new Deep(this.measurer, this.left.slice(0, -1), this.mid, this.left.slice(-1));
    }
  }

  peekFirst() {
    return this.left.peekFirst();
  }

  peekLast() {
    return this.right.peekLast();
  }

  isEmpty() {
    return false;
  }

  concat(other) {
    other = other.force();
    if (other instanceof Empty) {
      return this;
    } else if (other instanceof Single) {
      return this.addLast(other.value);
    } else {
      return app3(this, [], other);
    }
  }

  // Helper function to split the tree into 3 parts.
  // @private
  // @param {function(*): boolean} predicate
  // @param {*} initial The initial measurement for reducing
  // @return {Split}
  splitTree(predicate, initial) {
    var leftMeasure, midMeasure, midSplit, split;
    // see if the split point is inside the left tree
    leftMeasure = this.measurer.sum(initial, this.left.measure());
    if (predicate(leftMeasure)) {
      split = this.left.split(predicate, initial);
      return new Split(fromArray(split.left, this.measurer), split.mid, deepLeft(this.measurer, split.right, this.mid, this.right));
    } else {
      // see if the split point is inside the mid tree
      midMeasure = this.measurer.sum(leftMeasure, this.mid.measure());
      if (predicate(midMeasure)) {
        midSplit = this.mid.splitTree(predicate, leftMeasure);
        split = midSplit.mid.toDigit().split(predicate, this.measurer.sum(leftMeasure, midSplit.left.measure()));
        return new Split(deepRight(this.measurer, this.left, midSplit.left, split.left), split.mid, deepLeft(this.measurer, split.right, midSplit.right, this.right));
      } else {
        // the split point is in the right tree
        split = this.right.split(predicate, midMeasure);
        return new Split(deepRight(this.measurer, this.left, this.mid, split.left), split.mid, fromArray(split.right, this.measurer));
      }
    }
  }

  split(predicate) {
    var split;
    if (predicate(this.measure())) {
      split = this.splitTree(predicate, this.measurer.identity());
      return [split.left, split.right.addFirst(split.mid)];
    } else {
      return [this, new Empty(this.measurer)];
    }
  }

  toJSON() {
    return {
      type: 'deep',
      left: this.left,
      mid: this.mid,
      right: this.right,
      measure: this.measure()
    };
  }

};

// A lazy-evaluted finger-tree.
DelayedFingerTree = class DelayedFingerTree {
  // @param {function(): FingerTree} thunk A function, which when called, will
  constructor(thunk) {
    this.thunk = thunk;
    this.tree = null;
  }

  // Evaluate the thunk and return the finger-tree.
  // @return {FingerTree}
  force() {
    if (this.tree === null) {
      this.tree = this.thunk();
    }
    return this.tree;
  }

  isEmpty(v) {
    return this.force().isEmpty();
  }

  measure() {
    return this.force().measure();
  }

  peekFirst() {
    return this.force().peekFirst();
  }

  peekLast() {
    return this.force().peekLast();
  }

  addFirst(v) {
    return this.force().addFirst(v);
  }

  addLast(v) {
    return this.force().addLast(v);
  }

  removeFirst() {
    return this.force().removeFirst();
  }

  removeLast() {
    return this.force().removeLast();
  }

  concat(other) {
    return this.force().concat(other);
  }

  splitTree(predicate, initial) {
    return this.force().splitTree(predicate, initial);
  }

  split(predicate) {
    return this.force().split(predicate);
  }

  takeUntil(predicate) {
    return this.force().takeUntil(other);
  }

  dropUntil(predicate) {
    return this.force().dropUntil(other);
  }

  toJSON() {
    return this.force().toJSON();
  }

  toArray() {
    return this.force().toArray();
  }

};

// @param {Array} left
// @param {FingerTree} mid
// @param {Digit} right
deepLeft = function(measurer, left, mid, right) {
  if (!left.length) {
    if (mid.isEmpty()) {
      return fromArray(right.items, measurer);
    } else {
      return new DelayedFingerTree(function() {
        return new Deep(measurer, mid.peekFirst().toDigit(), mid.removeFirst(), right);
      });
    }
  } else {
    return new Deep(measurer, new Digit(measurer, left), mid, right);
  }
};

// @param {Digit} left
// @param {FingerTree} mid
// @param {Array} right
deepRight = function(measurer, left, mid, right) {
  if (!right.length) {
    if (mid.isEmpty()) {
      return fromArray(left.items, measurer);
    } else {
      return new DelayedFingerTree(function() {
        return new Deep(measurer, left, mid.removeLast(), mid.peekLast().toDigit());
      });
    }
  } else {
    return new Deep(measurer, left, mid, new Digit(measurer, right));
  }
};

// Helper function to concatenate two finger-trees with additional elements
// in between.
// @param {FingerTree} t1 Left finger-tree
// @param {Array} ts An array of elements in between the two finger-trees
// @param {FingerTree} t2 Right finger-tree
// @return {FingerTree}
app3 = function(t1, ts, t2) {
  t1 = t1.force();
  t2 = t2.force();
  if (t1 instanceof Empty) {
    return prepend(t2, ts);
  } else if (t2 instanceof Empty) {
    return append(t1, ts);
  } else if (t1 instanceof Single) {
    return prepend(t2, ts).addFirst(t1.value);
  } else if (t2 instanceof Single) {
    return append(t1, ts).addLast(t2.value);
  } else {
    return new Deep(t1.measurer, t1.left, new DelayedFingerTree(function() {
      return app3(t1.mid, nodes(t1.measurer, t1.right.items.concat(ts).concat(t2.left.items)), t2.mid);
    }), t2.right);
  }
};

// Helper function to group an array of elements into an array of nodes.
// @param {Object.<string, function>} m Measurer
// @param {Array} xs
// @return {Array}
nodes = function(m, xs, res) {
  res = res != null ? res : [];
  switch (xs.length) {
    case 2:
      res.push(new Node(m, xs));
      break;
    case 3:
      res.push(new Node(m, xs));
      break;
    case 4:
      res.push(new Node(m, [xs[0], xs[1]]), new Node(m, [xs[2], xs[3]]));
      break;
    default:
      res.push(new Node(m, [xs[0], xs[1], xs[2]]));
      nodes(m, xs.slice(3), res);
  }
  return res;
};

// Construct a derived measurer which will return the memoized
// measurement of a node instead of evaluting the node.
// @param {Object.<string, function>} measurer
// @return {Object.<string, function>}
makeNodeMeasurer = function(measurer) {
  return {
    identity: measurer.identity,
    measure: function(n) {
      return n.measure();
    },
    sum: measurer.sum
  };
};

// Prepend an array of elements to the left of a tree.
// Returns a new tree with the original one unmodified.
// @param {FingerTree} tree
// @param {Array} xs
// @return {FingerTree}
prepend = function(tree, xs) {
  var i, j, ref;
  for (i = j = ref = xs.length - 1; j >= 0; i = j += -1) {
    tree = tree.addFirst(xs[i]);
  }
  return tree;
};

// Append an array of elements to the right of a tree.
// Returns a new tree with the original one unmodified.
// @param {FingerTree} tree
// @param {Array} xs
// @return {FingerTree}
append = function(tree, xs) {
  var j, len, x;
  for (j = 0, len = xs.length; j < len; j++) {
    x = xs[j];
    tree = tree.addLast(x);
  }
  return tree;
};

// Construct a fingertree from an array.
// @param {Array} xs An array of elements.
// @param {Object.<string, function>} measurer
// @return {FingerTree}
fromArray = function(xs, measurer) {
  measurer = measurer || {
    identity: function() {
      return 0;
    },
    measure: function(v) {
      return 1;
    },
    sum: function(a, b) {
      return a + b;
    }
  };
  return prepend(new Empty(measurer), xs);
};

FingerTree.fromArray = fromArray;

//# sourceMappingURL=fingertree.js.map

// Generated by CoffeeScript 1.9.1
(function() {
  var BS, BasicEditingOptions, DEL, DOWN, DataStore, DataStoreEditingOptions, END, ENTER, HOME, LEFT, LeisureEditCore, Observable, PAGEDOWN, PAGEUP, RIGHT, TAB, UP, _to_ascii, blockText, defaultBindings, dragRange, escapeHtml, getEventChar, htmlForNode, idCounter, isEditable, keyFuncs, last, link, maxLastKeys, modifiers, modifyingKey, posFor, replacements, root, selectRange, shiftKey, shiftUps, specialKeys,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  selectRange = window.DOMCursor.selectRange;

  maxLastKeys = 4;

  BS = 8;

  ENTER = 13;

  DEL = 46;

  TAB = 9;

  LEFT = 37;

  UP = 38;

  RIGHT = 39;

  DOWN = 40;

  HOME = 36;

  END = 35;

  PAGEUP = 33;

  PAGEDOWN = 34;

  specialKeys = {};

  specialKeys[TAB] = 'TAB';

  specialKeys[ENTER] = 'ENTER';

  specialKeys[BS] = 'BS';

  specialKeys[DEL] = 'DEL';

  specialKeys[LEFT] = 'LEFT';

  specialKeys[RIGHT] = 'RIGHT';

  specialKeys[UP] = 'UP';

  specialKeys[DOWN] = 'DOWN';

  specialKeys[PAGEUP] = 'PAGEUP';

  specialKeys[PAGEDOWN] = 'PAGEDOWN';

  specialKeys[HOME] = 'HOME';

  specialKeys[END] = 'END';

  keyFuncs = {
    backwardChar: function(editor, e, r) {
      e.preventDefault();
      editor.moveSelectionBackward(r);
      return false;
    },
    forwardChar: function(editor, e, r) {
      e.preventDefault();
      editor.moveSelectionForward(r);
      return false;
    },
    previousLine: function(editor, e, r) {
      e.preventDefault();
      editor.moveSelectionUp(r);
      return false;
    },
    nextLine: function(editor, e, r) {
      e.preventDefault();
      editor.moveSelectionDown(r);
      return false;
    }
  };

  defaultBindings = {
    'C-Z': function() {
      return alert('UNDO not supported yet');
    },
    'C-S-Z': function() {
      return alert('REDO not supported yet');
    },
    'C-Y': function() {
      return alert('REDO not supported yet');
    },
    'UP': keyFuncs.previousLine,
    'DOWN': keyFuncs.nextLine,
    'LEFT': keyFuncs.backwardChar,
    'RIGHT': keyFuncs.forwardChar
  };

  dragRange = null;

  idCounter = 0;

  Observable = (function() {
    function Observable() {
      this.listeners = {};
    }

    Observable.prototype.on = function(type, callback) {
      if (!this.listeners[type]) {
        this.listeners[type] = [];
      }
      this.listeners[type].push(callback);
      return this;
    };

    Observable.prototype.trigger = function() {
      var args, j, len, listener, ref, results, type;
      type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref = this.listeners[type] || [];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        listener = ref[j];
        results.push(listener.apply(null, args));
      }
      return results;
    };

    return Observable;

  })();

  LeisureEditCore = (function(superClass) {
    extend(LeisureEditCore, superClass);

    function LeisureEditCore(node1, options) {
      this.node = node1;
      this.options = options;
      LeisureEditCore.__super__.constructor.call(this);
      this.node.attr('contenteditable', 'true').attr('spellcheck', 'false');
      this.curKeyBinding = this.prevKeybinding = null;
      this.bind();
      this.lastKeys = [];
      this.modCancelled = false;
      this.clipboardKey = null;
      this.ignoreModCheck = 0;
      this.movementGoal = null;
      this.options.setEditor(this);
    }

    LeisureEditCore.prototype.getCopy = function(id) {
      var bl, k, old, v;
      if (old = this.options.getBlock(id)) {
        bl = {};
        for (k in old) {
          v = old[k];
          bl[k] = v;
        }
        return bl;
      }
    };

    LeisureEditCore.prototype.domCursor = function(node, pos) {
      if (node instanceof jQuery) {
        node = node[0];
        pos = pos != null ? pos : 0;
      }
      return this.options.domCursor(node, pos);
    };

    LeisureEditCore.prototype.domCursorForText = function(node, pos, parent) {
      var c;
      c = this.domCursor(node, pos).filterTextNodes().firstText();
      if (parent != null) {
        return c.filterParent(parent);
      } else {
        return c;
      }
    };

    LeisureEditCore.prototype.domCursorForTextPosition = function(parent, pos, contain) {
      return this.domCursorForText(parent, 0, (contain ? parent : void 0)).mutable().forwardChars(pos, contain).adjustForNewline();
    };

    LeisureEditCore.prototype.domCursorForCaret = function() {
      var n, sel;
      sel = getSelection();
      n = this.domCursor(sel.focusNode, sel.focusOffset).mutable().filterVisibleTextNodes().filterParent(this.node[0]).firstText();
      if (n.isEmpty() || n.pos <= n.node.length) {
        return n;
      } else {
        return n.next();
      }
    };

    LeisureEditCore.prototype.getTextPosition = function(parent, target, pos) {
      var targ;
      if (parent) {
        targ = this.domCursorForText(target, pos);
        if (!this.options.getContainer(targ.node)) {
          targ = targ.prev();
        }
        return this.domCursorForText(parent, 0, parent).mutable().countChars(targ.node, targ.pos);
      } else {
        return -1;
      }
    };

    LeisureEditCore.prototype.loadURL = function(url) {
      return $.get(url, (function(_this) {
        return function(text) {
          return _this.options.load(text);
        };
      })(this));
    };

    LeisureEditCore.prototype.getSelectedBlockRange = function() {
      var p, s;
      s = getSelection();
      if (s.type === 'None') {
        return {
          type: 'None'
        };
      } else {
        p = this.blockOffset(s.anchorNode, s.anchorOffset);
        p.type = s.type;
        p.length = this.selectedText(s).length;
        return p;
      }
    };

    LeisureEditCore.prototype.selectBlockRange = function(blockRange) {
      if (blockRange.type === 'None') {
        return getSelection().removeAllRanges();
      } else {
        return selectRange(this.rangeForBlockRange(blockRange));
      }
    };

    LeisureEditCore.prototype.rangeForBlockRange = function(arg) {
      var block, endPos, length, offset, r, startPos;
      block = arg.block, offset = arg.offset, length = arg.length;
      startPos = this.domCursor(this.options.nodeForId(block._id), 0).forwardChars(offset);
      endPos = startPos.forwardChars(length);
      r = document.createRange();
      r.setStart(startPos.node, startPos.pos);
      r.setEnd(endPos.node, endPos.pos);
      return r;
    };

    LeisureEditCore.prototype.blockOffset = function(node, offset) {
      var startHolder;
      if (node instanceof Range) {
        offset = node.startOffset;
        node = node.startContainer;
      } else if (node instanceof DOMCursor) {
        offset = node.pos;
        node = node.node;
      }
      startHolder = this.options.getContainer(node);
      return {
        block: this.options.getBlock(this.options.idForNode(startHolder)),
        offset: this.getTextPosition(startHolder, node, offset)
      };
    };

    LeisureEditCore.prototype.blockRangeForOffsets = function(start, length) {
      var block, offset, ref;
      ref = this.options.getBlockOffsetForPosition(start), block = ref.block, offset = ref.offset;
      return {
        block: block,
        offset: offset,
        length: length,
        type: length === 0 ? 'Caret' : 'Range'
      };
    };

    LeisureEditCore.prototype.replace = function(e, br, text, select) {
      var blocks, cur, endOffset, tot;
      e.preventDefault();
      blocks = [br.block];
      endOffset = br.offset;
      if (br.type === 'Range') {
        tot = br.length - br.offset;
        cur = br.block;
        while (tot > 0) {
          blocks.push(cur = this.options.getBlock(cur.next));
          tot -= cur.text.length;
        }
      }
      return this.editBlocks(blocks, br.offset, br.length, text != null ? text : getEventChar(e), select);
    };

    LeisureEditCore.prototype.backspace = function(event, sel, r) {
      var holderId;
      if (sel.type === 'Range') {
        return this.cutText(event);
      }
      holderId = this.idAtCaret(sel);
      this.currentBlockIds = [holderId];
      return this.handleDelete(event, sel, false, function(text, pos) {
        return true;
      });
    };

    LeisureEditCore.prototype.del = function(event, sel, r) {
      var holderId;
      if (sel.type === 'Range') {
        return this.cutText(event);
      }
      holderId = this.idAtCaret(sel);
      this.currentBlockIds = [holderId];
      return this.handleDelete(event, sel, true, function(text, pos) {
        return true;
      });
    };

    LeisureEditCore.prototype.idAtCaret = function(sel) {
      return this.options.idForNode(this.options.getContainer(sel.anchorNode));
    };

    LeisureEditCore.prototype.selectedText = function(s) {
      return this.domCursor(s.anchorNode, s.anchorOffset).getTextTo(this.domCursor(s.focusNode, s.focusOffset));
    };

    LeisureEditCore.prototype.cutText = function(e) {
      var html, node, sel, text;
      e.preventDefault();
      sel = getSelection();
      if (sel.type === 'Range') {
        html = ((function() {
          var j, len, ref, results;
          ref = sel.getRangeAt(0).cloneContents().childNodes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            node = ref[j];
            results.push(htmlForNode(node));
          }
          return results;
        })()).join('');
        text = this.selectedText(sel);
        this.options.simulateCut({
          html: html,
          text: text
        });
        return this.replace(e, this.getSelectedBlockRange(), '');
      }
    };

    LeisureEditCore.prototype.handleDelete = function(e, s, forward, delFunc) {
      var bl, block, blocks, c, cont, pos, result;
      e.preventDefault();
      if (s.type === 'Caret') {
        c = this.domCursorForCaret().firstText();
        cont = this.options.getContainer(c.node);
        block = this.getCopy(this.options.idForNode(cont));
        pos = this.getTextPosition(cont, c.node, c.pos);
        result = delFunc(block.text, pos);
        blocks = [];
        if (!result) {
          return this.ignoreModCheck = this.ignoreModCheck || 1;
        } else {
          pos += forward ? 0 : -1;
          if (pos < 0) {
            if (block.prev) {
              blocks.push(bl = this.getCopy(block.prev));
              pos += bl.text.length;
            } else {
              return;
            }
          } else {
            blocks.push(block);
          }
          return this.editBlocks(blocks, pos, 1, '');
        }
      }
    };

    LeisureEditCore.prototype.editBlocks = function(blocks, start, length, newContent, select) {
      var block, caret, endPos, newBlocks, newText, offset, oldBlocks, oldText, r, ref, startBlock, startPos;
      caret = start + newContent.length;
      oldText = blockText(blocks);
      newText = oldText.substring(0, start) + newContent + oldText.substring(start + length);
      ref = this.changeStructure(blocks, newText), oldBlocks = ref.oldBlocks, newBlocks = ref.newBlocks, offset = ref.offset;
      if (oldBlocks.length || newBlocks.length) {
        this.options.edit(oldBlocks, newBlocks);
        if (!newBlocks.length) {
          offset = 0;
          if (!(startBlock = this.options.getBlock(this.options.getBlock(oldBlocks[0].prev).next))) {
            return;
          }
        } else {
          startBlock = newBlocks[0];
          offset += start;
          while (offset < 0) {
            if (!(block = this.options.getBlock(startBlock.prev))) {
              offset = 0;
              break;
            }
            startBlock = block;
            offset += startBlock.text.length;
          }
          while (offset > startBlock.text.length) {
            if (!(block = this.options.getBlock(startBlock.next))) {
              offset = startBlock.text.length;
              break;
            }
            offset -= startBlock.text.length;
            startBlock = block;
          }
        }
        startPos = this.domCursor(this.options.nodeForId(startBlock._id), 0);
        if (select) {
          r = document.createRange();
          startPos = startPos.forwardChars(offset, true);
          r.setStart(startPos.node, startPos.pos);
          endPos = startPos.forwardChars(newContent.length, true);
          r.setEnd(endPos.node, endPos.pos);
          return selectRange(r);
        } else {
          return startPos.forwardChars(offset + newContent.length, true).moveCaret();
        }
      }
    };

    LeisureEditCore.prototype.changeStructure = function(oldBlocks, newText) {
      var newBlocks, next, offset, oldText, prev;
      oldBlocks = oldBlocks.slice();
      oldText = null;
      offset = 0;
      while (oldText !== newText && (oldBlocks[0].prev || last(oldBlocks).next)) {
        oldText = newText;
        if (prev = this.options.getBlock(oldBlocks[0].prev)) {
          oldBlocks.unshift(prev);
          newText = prev.text + newText;
          offset += prev.text.length;
        }
        if (next = this.options.getBlock(last(oldBlocks).next)) {
          oldBlocks.push(next);
          newText += next.text;
        }
        newBlocks = this.options.parseBlocks(newText);
        if ((!prev || prev.text === newBlocks[0].text) && (!next || next.text === last(newBlocks).text)) {
          break;
        }
      }
      while (oldBlocks.length && newBlocks.length && oldBlocks[0].text === newBlocks[0].text) {
        offset -= oldBlocks[0].text.length;
        oldBlocks.shift();
        newBlocks.shift();
      }
      while (oldBlocks.length && newBlocks.length && last(oldBlocks).text === last(newBlocks).text) {
        oldBlocks.pop();
        newBlocks.pop();
      }
      return {
        oldBlocks: oldBlocks,
        newBlocks: newBlocks,
        offset: offset
      };
    };

    LeisureEditCore.prototype.bind = function() {
      this.bindDragAndDrop();
      this.bindClipboard();
      this.bindMouse();
      return this.bindKeyboard();
    };

    LeisureEditCore.prototype.bindDragAndDrop = function() {
      this.node.on('dragover', (function(_this) {
        return function(e) {
          _this.options.dragOver(e.originalEvent);
          return true;
        };
      })(this));
      this.node.on('dragenter', (function(_this) {
        return function(e) {
          _this.options.dragEnter(e.originalEvent);
          return true;
        };
      })(this));
      this.node.on('drop', (function(_this) {
        return function(e) {
          var blockId, cutOffset, dr, dropContainer, dropPos, insert, insertOffset, insertText, oe, offset, r, r2, start;
          oe = e.originalEvent;
          oe.dataTransfer.dropEffect = 'move';
          r = document.caretRangeFromPoint(oe.clientX, oe.clientY);
          dropPos = _this.domCursor(r.startContainer, r.startOffset).moveCaret();
          dropContainer = _this.domCursor(_this.options.getContainer(r.startContainer), 0);
          blockId = _this.options.idForNode(dropContainer.node);
          offset = dropContainer.countChars(dropPos);
          insertText = oe.dataTransfer.getData('text/plain');
          insert = function() {
            return _this.replace(e, {
              type: 'Caret',
              offset: offset,
              block: _this.options.getBlock(blockId),
              length: 0
            }, insertText, false);
          };
          if (dragRange) {
            start = _this.domCursor(_this.options.nodeForId(dragRange.block._id), 0).forwardChars(dragRange.offset);
            r2 = start.range(start.forwardChars(dragRange.length));
            insertOffset = _this.options.getPositionForBlock(_this.options.getBlock(blockId)) + offset;
            cutOffset = _this.options.getPositionForBlock(dragRange.block) + dragRange.offset;
            if ((cutOffset <= insertOffset && insertOffset <= cutOffset + dragRange.length)) {
              oe.preventDefault();
              oe.dataTransfer.dropEffect = 'none';
              return;
            }
            dr = dragRange;
            if (insertOffset <= cutOffset) {
              _this.replace(e, dragRange, '', false);
              _this.replace(e, _this.blockRangeForOffsets(insertOffset, 0), insertText, false);
            } else {
              insert();
              _this.replace(e, _this.blockRangeForOffsets(cutOffset, dragRange.length), '', false);
            }
            dragRange = null;
          } else {
            insert();
          }
          return true;
        };
      })(this));
      this.node.on('dragstart', (function(_this) {
        return function(e) {
          var clipboard, node, sel;
          sel = getSelection();
          if (sel.type === 'Range') {
            dragRange = _this.getSelectedBlockRange();
            clipboard = e.originalEvent.dataTransfer;
            clipboard.setData('text/html', ((function() {
              var j, len, ref, results;
              ref = sel.getRangeAt(0).cloneContents().childNodes;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                node = ref[j];
                results.push(htmlForNode(node));
              }
              return results;
            })()).join(''));
            clipboard.setData('text/plain', _this.selectedText(sel));
            clipboard.effectAllowed = 'copyMove';
            clipboard.dropEffect = 'move';
          }
          return true;
        };
      })(this));
      return this.node[0].addEventListener('dragend', (function(_this) {
        return function(e) {
          var sel;
          if (dragRange) {
            if (e.dataTransfer.dropEffect === 'move') {
              sel = _this.getSelectedBlockRange();
              _this.replace(e, dragRange, '');
              _this.selectBlockRange(sel);
            }
            return dragRange = null;
          }
        };
      })(this));
    };

    LeisureEditCore.prototype.bindClipboard = function() {
      this.node.on('cut', (function(_this) {
        return function(e) {
          var clipboard, node, sel;
          e.preventDefault();
          sel = getSelection();
          if (sel.type === 'Range') {
            clipboard = e.originalEvent.clipboardData;
            clipboard.setData('text/html', ((function() {
              var j, len, ref, results;
              ref = sel.getRangeAt(0).cloneContents().childNodes;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                node = ref[j];
                results.push(htmlForNode(node));
              }
              return results;
            })()).join(''));
            clipboard.setData('text/plain', _this.selectedText(sel));
            return _this.replace(e, _this.getSelectedBlockRange(), '');
          }
        };
      })(this));
      this.node.on('copy', (function(_this) {
        return function(e) {
          var clipboard, node, sel;
          e.preventDefault();
          sel = getSelection();
          if (sel.type === 'Range') {
            clipboard = e.originalEvent.clipboardData;
            clipboard.setData('text/html', ((function() {
              var j, len, ref, results;
              ref = sel.getRangeAt(0).cloneContents().childNodes;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                node = ref[j];
                results.push(htmlForNode(node));
              }
              return results;
            })()).join(''));
            return clipboard.setData('text/plain', _this.selectedText(sel));
          }
        };
      })(this));
      return this.node.on('paste', (function(_this) {
        return function(e) {
          return _this.replace(e, _this.getSelectedBlockRange(), e.originalEvent.clipboardData.getData('text/plain'), false);
        };
      })(this));
    };

    LeisureEditCore.prototype.bindMouse = function() {
      this.node.on('mousedown', (function(_this) {
        return function(e) {
          setTimeout((function() {
            return _this.trigger('moved', _this);
          }), 1);
          return _this.setCurKeyBinding(null);
        };
      })(this));
      return this.node.on('mouseup', (function(_this) {
        return function(e) {
          _this.adjustSelection(e);
          return _this.trigger('moved', _this);
        };
      })(this));
    };

    LeisureEditCore.prototype.bindKeyboard = function() {
      this.node.on('keyup', (function(_this) {
        return function(e) {
          return _this.handleKeyup(e);
        };
      })(this));
      return this.node.on('keydown', (function(_this) {
        return function(e) {
          var bound, c, checkMod, r, ref, s;
          _this.modCancelled = false;
          c = e.charCode || e.keyCode || e.which;
          if (!_this.addKeyPress(e, c)) {
            return;
          }
          s = getSelection();
          r = s.rangeCount > 0 && s.getRangeAt(0);
          _this.currentBlockIds = _this.blockIdsForSelection(s, r);
          ref = _this.findKeyBinding(e, r), bound = ref[0], checkMod = ref[1];
          if (bound) {
            return _this.modCancelled = !checkMod;
          } else {
            _this.modCancelled = false;
            if (c === ENTER) {
              return _this.replace(e, _this.getSelectedBlockRange(), '\n', false);
            } else if (c === BS) {
              return _this.backspace(e, s, r);
            } else if (c === DEL) {
              return _this.del(e, s, r);
            } else if (modifyingKey(c, e)) {
              return _this.replace(e, _this.getSelectedBlockRange(), null, false);
            }
          }
        };
      })(this));
    };

    LeisureEditCore.prototype.blockIdsForSelection = function(sel, r) {
      var blocks, cont, cur, end;
      if (!sel) {
        sel = getSelection();
      }
      if (sel.rangeCount === 1) {
        if (!r) {
          r = sel.getRangeAt(0);
        }
        blocks = (cont = this.options.getContainer(r.startContainer)) ? [this.options.idForNode(cont)] : [];
        if (!(r != null ? r.collapsed : void 0)) {
          cur = blocks[0];
          end = this.options.idForNode(this.options.getContainer(r.endContainer));
          while (cur && cur !== end) {
            if (cur = (this.getCopy(cur)).next) {
              blocks.push(cur);
            }
          }
        }
        return blocks;
      }
    };

    LeisureEditCore.prototype.setCurKeyBinding = function(f) {
      this.prevKeybinding = this.curKeyBinding;
      return this.curKeyBinding = f;
    };

    LeisureEditCore.prototype.addKeyPress = function(e, c) {
      var i, j, notShift, ref;
      if (notShift = !shiftKey(c)) {
        e.DE_editorShiftkey = true;
        this.lastKeys.push(modifiers(e, c));
        while (this.lastKeys.length > maxLastKeys) {
          this.lastKeys.shift();
        }
        this.keyCombos = new Array(maxLastKeys);
        for (i = j = 0, ref = Math.min(this.lastKeys.length, maxLastKeys); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.keyCombos[i] = this.lastKeys.slice(this.lastKeys.length - i - 1, this.lastKeys.length).join(' ');
        }
        this.keyCombos.reverse();
      }
      return notShift;
    };

    LeisureEditCore.prototype.findKeyBinding = function(e, r) {
      var f, j, k, len, ref;
      ref = this.keyCombos;
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        if (f = this.options.bindings[k]) {
          this.lastKeys = [];
          this.keyCombos = [];
          this.setCurKeyBinding(f);
          return [true, f(this, e, r)];
        }
      }
      this.setCurKeyBinding(null);
      return [false];
    };

    LeisureEditCore.prototype.handleKeyup = function(e) {
      if (this.ignoreModCheck = this.ignoreModCheck) {
        this.ignoreModCheck--;
      }
      if (this.clipboardKey || (!e.DE_shiftkey && !this.modCancelled && modifyingKey(e.charCode || e.keyCode || e.which, e))) {
        this.options.keyUp();
        return this.clipboardKey = null;
      }
    };

    LeisureEditCore.prototype.adjustSelection = function(e) {
      var pos, r, s;
      if (e.detail === 1) {
        return;
      }
      s = getSelection();
      if (s.type === 'Range') {
        r = s.getRangeAt(0);
        pos = this.domCursor(r.endContainer, r.endOffset).mutable().filterVisibleTextNodes().firstText();
        while (pos.node !== r.startContainer && pos.node.data.trim() === '') {
          pos === pos.prev();
        }
        while (pos.pos > 0 && pos.node.data[pos.pos - 1] === ' ') {
          pos.pos--;
        }
        if ((pos.node !== r.startContainer || pos.pos > r.startOffset) && (pos.node !== r.endContainer || pos.pos < r.endOffset)) {
          r.setEnd(pos.node, pos.pos);
          return selectRange(r);
        }
      }
    };

    LeisureEditCore.prototype.moveSelectionForward = function() {
      return this.showCaret(this.moveForward());
    };

    LeisureEditCore.prototype.moveSelectionDown = function() {
      return this.showCaret(this.moveDown());
    };

    LeisureEditCore.prototype.moveSelectionBackward = function() {
      return this.showCaret(this.moveBackward());
    };

    LeisureEditCore.prototype.moveSelectionUp = function() {
      return this.showCaret(this.moveUp());
    };

    LeisureEditCore.prototype.showCaret = function(pos) {
      if (pos.isEmpty()) {
        pos = pos.prev();
      }
      pos = this.domCursorForCaret();
      pos.moveCaret();
      pos.show(this.options.topRect());
      return this.trigger('moved', this);
    };

    LeisureEditCore.prototype.moveForward = function() {
      var pos, start;
      start = pos = this.domCursorForCaret().firstText().save();
      while (!pos.isEmpty() && this.domCursorForCaret().firstText().equals(start)) {
        pos = pos.forwardChar();
        pos.moveCaret();
      }
      return pos;
    };

    LeisureEditCore.prototype.moveBackward = function() {
      var pos, start;
      start = pos = this.domCursorForCaret().firstText().save();
      while (!pos.isEmpty() && this.domCursorForCaret().firstText().equals(start)) {
        pos = pos.backwardChar();
        pos.moveCaret();
      }
      return pos;
    };

    LeisureEditCore.prototype.firstText = function() {
      return this.domCursor(this.node, 0).firstText().node;
    };

    LeisureEditCore.prototype.moveDown = function() {
      var line, linePos, lineTop, p, pos, prev, ref;
      linePos = prev = pos = this.domCursorForCaret().save();
      if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
        this.movementGoal = this.options.blockColumn(pos);
        line = 0;
      } else {
        line = (pos.pos === 0 && pos.node === this.firstText() ? 1 : 0);
      }
      lineTop = posFor(linePos).top;
      while (!(pos = this.moveForward()).isEmpty()) {
        p = posFor(pos);
        if (lineTop < p.top) {
          line++;
          pos = linePos = p.pos;
          lineTop = p.top;
        }
        if (line === 2) {
          return prev.moveCaret();
        }
        if (line === 1 && this.options.blockColumn(pos) >= this.movementGoal) {
          return this.moveToBestPosition(pos, prev, linePos);
        }
        prev = pos;
      }
      return pos;
    };

    LeisureEditCore.prototype.moveUp = function() {
      var line, linePos, pos, prev, ref;
      linePos = prev = pos = this.domCursorForCaret().save();
      if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
        this.movementGoal = this.options.blockColumn(pos);
      }
      line = 0;
      while (!(pos = this.moveBackward()).isEmpty()) {
        if (linePos.differentLines(pos)) {
          line++;
          linePos = pos;
        }
        if (line === 2) {
          return prev.moveCaret();
        }
        if (line === 1 && this.options.blockColumn(pos) <= this.movementGoal) {
          return this.moveToBestPosition(pos, prev, linePos);
        }
        prev = pos;
      }
      return pos;
    };

    LeisureEditCore.prototype.moveToBestPosition = function(pos, prev, linePos) {
      if (linePos === pos || Math.abs(this.options.blockColumn(pos) - this.movementGoal) < Math.abs(this.options.blockColumn(prev) - this.movementGoal)) {
        return pos;
      } else {
        return prev.moveCaret();
      }
    };

    return LeisureEditCore;

  })(Observable);

  BasicEditingOptions = (function(superClass) {
    extend(BasicEditingOptions, superClass);

    BasicEditingOptions.prototype.parseBlocks = function(text) {
      throw new Error("options.parseBlocks(text) is not implemented");
    };

    BasicEditingOptions.prototype.renderBlock = function(block) {
      throw new Error("options.renderBlock(block) is not implemented");
    };

    BasicEditingOptions.prototype.edit = function(oldBlocks, newBlocks) {
      throw new Error("options.edit(func) is not implemented");
    };

    BasicEditingOptions.prototype.simulateCut = function(arg) {
      var html, text;
      html = arg.html, text = arg.text;
    };

    BasicEditingOptions.prototype.dragEnter = function(event) {
      if (!event.dataTransfer.getData) {
        event.preventDefault();
        return event.dropEffect = 'none';
      }
    };

    BasicEditingOptions.prototype.dragOver = function(event) {
      if (!event.dataTransfer.getData) {
        event.preventDefault();
        return event.dropEffect = 'none';
      }
    };

    function BasicEditingOptions() {
      BasicEditingOptions.__super__.constructor.call(this);
      this.blocks = {};
      this.first = null;
    }

    BasicEditingOptions.prototype.getFirst = function() {
      return this.first;
    };

    BasicEditingOptions.prototype.nodeForId = function(id) {
      return $("#" + id);
    };

    BasicEditingOptions.prototype.idForNode = function(node) {
      return $(node).prop(id);
    };

    BasicEditingOptions.prototype.setEditor = function(editor1) {
      this.editor = editor1;
    };

    BasicEditingOptions.prototype.newId = function() {
      return "block" + (idCounter++);
    };

    BasicEditingOptions.prototype.copyBlock = function(block) {
      var bl, k, v;
      if (!block) {
        return null;
      } else {
        bl = {};
        for (k in block) {
          v = block[k];
          bl[k] = v;
        }
        return bl;
      }
    };

    BasicEditingOptions.prototype.replaceBlocks = function(oldBlocks, newBlocks) {
      return this.change(this.changesFor(oldBlocks, newBlocks));
    };

    BasicEditingOptions.prototype.changesFor = function(oldBlocks, newBlocks) {
      var changes, newBlockMap, prev, removes;
      newBlockMap = {};
      removes = {};
      changes = {
        removes: removes,
        sets: newBlockMap,
        first: this.getFirst(),
        oldBlocks: oldBlocks,
        newBlocks: newBlocks
      };
      prev = this.computeRemovesAndNewBlockIds(oldBlocks, newBlocks, newBlockMap, removes);
      this.patchNewBlocks(oldBlocks, newBlocks, changes, newBlockMap, removes, prev);
      this.removeDuplicateChanges(newBlockMap);
      return changes;
    };

    BasicEditingOptions.prototype.computeRemovesAndNewBlockIds = function(oldBlocks, newBlocks, newBlockMap, removes) {
      var i, j, l, len, len1, newBlock, oldBlock, prev, ref;
      ref = oldBlocks.slice(newBlocks.length, oldBlocks.length);
      for (j = 0, len = ref.length; j < len; j++) {
        oldBlock = ref[j];
        removes[oldBlock._id] = oldBlock;
      }
      prev = null;
      for (i = l = 0, len1 = newBlocks.length; l < len1; i = ++l) {
        newBlock = newBlocks[i];
        if (oldBlock = oldBlocks[i]) {
          newBlock._id = oldBlock._id;
          newBlock.prev = oldBlock.prev;
          newBlock.next = oldBlock.next;
        } else {
          newBlock._id = this.newId();
          if (prev) {
            link(prev, newBlock);
          }
        }
        prev = newBlockMap[newBlock._id] = newBlock;
      }
      return prev;
    };

    BasicEditingOptions.prototype.patchNewBlocks = function(oldBlocks, newBlocks, changes, newBlockMap, removes, prev) {
      var lastBlock, next;
      if (oldBlocks.length !== newBlocks.length) {
        if (!prev && (prev = this.copyBlock(this.getBlock(oldBlocks[0].prev)))) {
          newBlockMap[prev._id] = prev;
        }
        lastBlock = last(oldBlocks);
        if (next = this.copyBlock(this.getBlock((lastBlock ? lastBlock.next : this.getFirst())))) {
          newBlockMap[next._id] = next;
          if (!(next.prev = prev != null ? prev._id : void 0)) {
            changes.first = next._id;
          }
        }
        if (prev) {
          if (!oldBlocks.length || !this.getFirst() || removes[this.getFirst()]) {
            changes.first = newBlocks[0]._id;
          }
          return prev.next = next != null ? next._id : void 0;
        }
      }
    };

    BasicEditingOptions.prototype.removeDuplicateChanges = function(newBlockMap) {
      var block, dups, id, oldBlock, results;
      dups = [];
      for (id in newBlockMap) {
        block = newBlockMap[id];
        if ((oldBlock = this.getBlock(id)) && block.text === oldBlock.text && block.next === oldBlock.next && block.prev === oldBlock.prev) {
          dups.push(id);
        }
      }
      results = [];
      for (id in dups) {
        results.push(delete newBlockMap[id]);
      }
      return results;
    };

    BasicEditingOptions.prototype.change = function(arg) {
      var block, first, id, j, len, removes, results, sets;
      first = arg.first, removes = arg.removes, sets = arg.sets;
      this.first = first;
      for (j = 0, len = removes.length; j < len; j++) {
        id = removes[j];
        delete this.blocks[id];
      }
      results = [];
      for (id in sets) {
        block = sets[id];
        results.push(this.blocks[id] = block);
      }
      return results;
    };

    BasicEditingOptions.prototype.getBlock = function(id) {
      return this.blocks[id];
    };

    BasicEditingOptions.prototype.bindings = defaultBindings;

    BasicEditingOptions.prototype.blockColumn = function(pos) {
      return pos.textPosition().left;
    };

    BasicEditingOptions.prototype.topRect = function() {
      return null;
    };

    BasicEditingOptions.prototype.keyUp = function() {};

    BasicEditingOptions.prototype.domCursor = function(node, pos) {
      return new DOMCursor(node, pos).addFilter(function(n) {
        return (n.hasAttribute('data-noncontent') && 'skip') || isEditable(n.node);
      });
    };

    BasicEditingOptions.prototype.getContainer = function(node) {
      if (this.editor.node[0].compareDocumentPosition(node) & Element.DOCUMENT_POSITION_CONTAINED_BY) {
        return $(node).closest('[data-block]')[0];
      }
    };

    BasicEditingOptions.prototype.load = function(text) {
      this.replaceBlocks(this.blockList(), this.parseBlocks(text));
      this.editor.node.html(this.renderBlocks());
      return this.trigger('load');
    };

    BasicEditingOptions.prototype.blockCount = function() {
      var b, c;
      c = 0;
      for (b in this.blocks) {
        c++;
      }
      return c;
    };

    BasicEditingOptions.prototype.blockList = function() {
      var bl, next, results;
      next = this.getFirst();
      results = [];
      while (next) {
        bl = this.getBlock(next);
        next = bl.next;
        results.push(bl);
      }
      return results;
    };

    BasicEditingOptions.prototype.getPositionForBlock = function(block) {
      var cur, offset;
      cur = this.getBlock(this.getFirst());
      offset = 0;
      while (cur._id !== block._id) {
        offset += cur.text.length;
        cur = this.getBlock(cur.next);
      }
      return offset;
    };

    BasicEditingOptions.prototype.getBlockOffsetForPosition = function(pos) {
      var cur;
      cur = this.getBlock(this.getFirst());
      while (pos >= cur.text.length) {
        pos -= cur.text.length;
        cur = this.getBlock(cur.next);
      }
      return {
        block: cur,
        offset: pos
      };
    };

    BasicEditingOptions.prototype.renderBlocks = function() {
      var html, next, ref, result;
      result = '';
      next = this.getFirst();
      while (next && (ref = this.renderBlock(this.getBlock(next)), html = ref[0], next = ref[1], ref)) {
        result += html;
      }
      return result;
    };

    return BasicEditingOptions;

  })(Observable);

  DataStore = (function(superClass) {
    extend(DataStore, superClass);

    function DataStore() {
      DataStore.__super__.constructor.call(this);
      this.blocks = {};
    }

    DataStore.prototype.getBlock = function(id) {
      return this.blocks[id];
    };

    DataStore.prototype.load = function(changes) {
      this.change(changes);
      return this.trigger('load');
    };

    DataStore.prototype.check = function() {
      var bl, k, next, oldBl, prev, seen;
      seen = {};
      next = this.first;
      prev = null;
      while (next) {
        prev = next;
        if (seen[next]) {
          throw new Error("cycle in next links");
        }
        seen[next] = true;
        oldBl = bl;
        bl = this.blocks[next];
        if (!bl) {
          throw new Error("Next of " + oldBl.id + " doesn't exist");
        }
        next = bl.next;
      }
      for (k in this.blocks) {
        if (!seen[k]) {
          throw new Error(k + " not in next chain");
        }
      }
      seen = {};
      while (prev) {
        if (seen[prev]) {
          throw new Error("cycle in prev links");
        }
        seen[prev] = true;
        oldBl = bl;
        bl = this.blocks[prev];
        if (!bl) {
          throw new Error("Prev of " + oldBl.id + " doesn't exist");
        }
        prev = bl.prev;
      }
      for (k in this.blocks) {
        if (!seen[k]) {
          throw new Error(k + " not in prev chain");
        }
      }
      return null;
    };

    DataStore.prototype.blockList = function() {
      var bl, next, results;
      next = this.first;
      results = [];
      while (next) {
        bl = this.blocks[next];
        next = bl.next;
        results.push(bl);
      }
      return results;
    };

    DataStore.prototype.change = function(changes) {
      return this.trigger('change', this.makeChange(changes));
    };

    DataStore.prototype.makeChange = function(changes) {
      var adds, bl, block, id, old, ref, removes, result, updates;
      updates = {};
      adds = {};
      removes = [];
      old = {};
      result = {
        adds: adds,
        updates: updates,
        removes: removes,
        old: old,
        oldFirst: this.first
      };
      this.first = changes.first;
      for (id in changes.removes) {
        if (bl = this.blocks[id]) {
          old[id] = bl;
          removes[id] = true;
          delete this.blocks[id];
        }
      }
      ref = changes.sets;
      for (id in ref) {
        block = ref[id];
        if (this.blocks[id]) {
          old[id] = this.blocks[id];
          updates[id] = true;
        } else {
          adds[id] = block;
        }
        this.blocks[id] = block;
      }
      this.check();
      return result;
    };

    return DataStore;

  })(Observable);

  DataStoreEditingOptions = (function(superClass) {
    extend(DataStoreEditingOptions, superClass);

    function DataStoreEditingOptions(data) {
      this.data = data;
      DataStoreEditingOptions.__super__.constructor.call(this);
      this.data.on('change', (function(_this) {
        return function(changes) {
          return _this.changed(changes);
        };
      })(this));
    }

    DataStoreEditingOptions.prototype.load = function(text) {
      this.data.load(this.changesFor(this.blockList(), this.parseBlocks(text)));
      return this.trigger('load');
    };

    DataStoreEditingOptions.prototype.edit = function(oldBlocks, newBlocks) {
      return this.replaceBlocks(oldBlocks, newBlocks);
    };

    DataStoreEditingOptions.prototype.getBlock = function(id) {
      return this.data.getBlock(id);
    };

    DataStoreEditingOptions.prototype.getFirst = function(first) {
      return this.data.first;
    };

    DataStoreEditingOptions.prototype.change = function(changes) {
      return this.data.change(changes);
    };

    DataStoreEditingOptions.prototype.changed = function(changes) {
      return this.editor.node.html(this.renderBlocks());
    };

    return DataStoreEditingOptions;

  })(BasicEditingOptions);

  isEditable = function(n) {
    n = n.nodeType === n.TEXT_NODE ? n.parentNode : n;
    return n.isContentEditable;
  };

  link = function(prev, next) {
    prev.next = next._id;
    return next.prev = prev._id;
  };

  blockText = function(blocks) {
    var block;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = blocks.length; j < len; j++) {
        block = blocks[j];
        results.push(block.text);
      }
      return results;
    })()).join('');
  };

  _to_ascii = {
    '188': '44',
    '109': '45',
    '190': '46',
    '191': '47',
    '192': '96',
    '220': '92',
    '222': '39',
    '221': '93',
    '219': '91',
    '173': '45',
    '187': '61',
    '186': '59',
    '189': '45'
  };

  shiftUps = {
    "96": "~",
    "49": "!",
    "50": "@",
    "51": "#",
    "52": "$",
    "53": "%",
    "54": "^",
    "55": "&",
    "56": "*",
    "57": "(",
    "48": ")",
    "45": "_",
    "61": "+",
    "91": "{",
    "93": "}",
    "92": "|",
    "59": ":",
    "39": "\"",
    "44": "<",
    "46": ">",
    "47": "?"
  };

  htmlForNode = function(n) {
    if (n.nodeType === n.TEXT_NODE) {
      return escapeHtml(n.data);
    } else {
      return n.outerHTML;
    }
  };

  getEventChar = function(e) {
    var c;
    c = e.charCode || e.keyCode || e.which;
    if (_to_ascii.hasOwnProperty(c)) {
      c = _to_ascii[c];
    }
    if (!e.shiftKey && (c >= 65 && c <= 90)) {
      c = String.fromCharCode(c + 32);
    } else if (e.shiftKey && shiftUps.hasOwnProperty(c)) {
      c = shiftUps[c];
    } else {
      c = String.fromCharCode(c);
    }
    return c;
  };

  shiftKey = function(c) {
    return (15 < c && c < 19);
  };

  modifiers = function(e, c) {
    var res;
    res = specialKeys[c] || String.fromCharCode(c);
    if (e.altKey) {
      res = "M-" + res;
    }
    if (e.metaKey) {
      res = "M-" + res;
    }
    if (e.ctrlKey) {
      res = "C-" + res;
    }
    if (e.shiftKey) {
      res = "S-" + res;
    }
    return res;
  };

  modifyingKey = function(c, e) {
    return !e.altKey && !e.metaKey && !e.ctrlKey && (((47 < c && c < 58)) || c === 32 || c === ENTER || c === BS || c === DEL || ((64 < c && c < 91)) || ((95 < c && c < 112)) || ((185 < c && c < 193)) || ((218 < c && c < 223)));
  };

  last = function(array) {
    return array.length && array[array.length - 1];
  };

  posFor = function(pos) {
    var p, result;
    result = (pos.pos === pos.node.length && pos.node.data[pos.pos - 1] === '\n' && !(p = pos.save().next()).isEmpty() ? p : pos).textPosition();
    result.pos = p != null ? p : pos;
    return result;
  };

  replacements = {
    '<': "&lt;",
    '>': "&gt;",
    '&': "&amp;"
  };

  escapeHtml = function(str) {
    if (typeof str === 'string') {
      return str.replace(/[<>&]/g, function(c) {
        return replacements[c];
      });
    } else {
      return str;
    }
  };

  root = LeisureEditCore;

  root.Observable = Observable;

  root.BasicEditingOptions = BasicEditingOptions;

  root.DataStore = DataStore;

  root.DataStoreEditingOptions = DataStoreEditingOptions;

  root.defaultBindings = defaultBindings;

  root.last = last;

  root.link = link;

  root.blockText = blockText;

  root.posFor = posFor;

  root.escapeHtml = escapeHtml;

  if (typeof window !== "undefined" && window !== null) {
    window.LeisureEditCore = root;
  } else {
    module.exports = root;
  }

}).call(this);

//# sourceMappingURL=editor.js.map

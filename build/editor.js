// Generated by CoffeeScript 2.5.1
  // LeisureEditCore ([example editor](http://team-cthulhu.github.io/LeisureEditCore/examples/index.html))
  // ===============
  // Copyright (C) 2015, Bill Burdick, Roy Riggs, TEAM CTHULHU

// Licensed with ZLIB license (see "[License](#license)", below).

// Welcome to LeisureEditCore!  Are you trying to make editable documents
  // that are more than just text editors or word processors?  This library
  // tries to make it easier to make interesting editable documents.  You
  // can find it on [Github](https://github.com/TEAM-CTHULHU/LeisureEditCore).
  // LeisureEditCore what [Leisure's](https://github.com/zot/Leisure)
  // editor, extracted out into a small HTML5 library.  LeisureEditCore is
  // pluggable with an options object that contains customization hooks.
  // Code and examples are in Coffeescript (a JS build is provided as a
  // convenience).

// Basic Idea
  // ==========

// LeisureEditCore edits a doubly-linked list of newline-terminated text
  // "blocks" that can render as DOM nodes (and maybe in interesting ways!)

// The rendered DOM tree contains the full text of the block list in the
  // proper order, along with ids from the blocks.  Some of the text may
  // not be visible and there may be a lot of items in the rendered DOM
  // that are not in the blocks.  Also, the rendered DOM may have a nested
  // tree-structure.

// When the user makes a change, the editor:

//   1. maps the cursor location in the DOM to the corresponding location in the blocks
  //   2. changes block text, regenerating part of the blocks
  //   3. rerenders the DOM corresponding to the changed blocks
  //   4. replaces the new DOM into the page

// ![Editor flow](editorFlow.png)

// Of course the editor supports [custom key bindings](#defaultBindings).

// Using/Installing LeisureEditCore
  // ================================
  // Make sure your webpage loads the javascript files in the `build` directory.  Follow
  // the instructions below to use it.

// [Here](http://team-cthulhu.github.io/LeisureEditCore/examples/index.html) is an example that edits org-mode text.

// Blocks
  // ------
  //   * `_id`: the block id
  //   * `text`: the text of the block
  //   * `prev`: the id of the previous block (optional)
  //   * `next`: the id of the next block (optional)
  //   * EXTRA STUFF: you can store whatever extra things you like in your text blocks

// BlockOffsets
  // ------------
  // {block: aBlock, offset: aNumber}
  // aBlock can be an id or a block

// Editor (see below for more detailed documentation)
  // --------------------------------------------------
  // An instance of LeisureEditCore.  You must provide an HTML node to
  // contain the document contents and an options object to configure the
  // editor.

// Editor options object (see below for more detailed documentation)
  // -----------------------------------------------------------------
  // DataStoreEditingOptions is the recommended options object but
  // you can also subclass BasicEditingOptions.

// Data object (see below for more detailed documentation)
  // -------------------------------------------------------
  // Manages the document.  It's responsible for parsing text into blocks,
  // accessing the blocks, making changes, and converting between block
  // locations and document locations.

// Basic usage
  // -----------
  // To use this in the recommended way...

// 1. The code uses AMD style and depends on 'lodash', 'fingertree', and 'immutable' which you will probably need to map.  This is so that if you are using any of these packages, you won't have to include them more than once.
  // 1. Subclass DataStoreEditingOptions and provide a renderBlock(block) method
  // 1. Subclass DataStore and provide a parseBlocks(text) method
  // 1. Create an editor object with your options object on your data object
  // 1. Call the load(name, text) method on your options object

// Included packages
  // =================
  // - [DOMCursor](https://github.com/zot/DOMCursor) -- locating text in DOM trees

// Third-party packages we use (also included)
  // ===========================================
  // - [lodash](https://lodash.com/) -- collection, FP, and async utilities
  // - [fingertree](https://github.com/qiao/fingertree.js) -- the swiss army knife of data structures
  // - [immutable](http://facebook.github.io/immutable-js) -- immutable data structures

// Building
  // ========
  // If you modify LeisureEditCore and want to build it, you can use the Cakefile.  It needs the
  // `which` npm package (`npm install which`).

// <a name="license"></a>License
  // =============================
  // Licensed with ZLIB license.

// This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.

// Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:

// 1. The origin of this software must not be misrepresented; you must not
  // claim that you wrote the original software. If you use this software
  // in a product, an acknowledgment in the product documentation would be
  // appreciated but is not required.

// 2. Altered source versions must be plainly marked as such, and must not be
  // misrepresented as being the original software.

// 3. This notice may not be removed or altered from any source distribution.

// LeisureEditCore
  // ===============
  // Create a LeisureEditCore object like this: `new LeisureEditCore editorElement, options`.

// `editorElement` is the HTML element that you want to contain editable text.

// `options` is an object that tells LeisureEditCore things like how to
  // convert text to a list of block objects (see below).  See
  // BasicEditingOptions and DataStoreEditingOptions for more info.
var BS, BlockErrors, DEL, DOWN, END, ENTER, FJQData, HOME, LEFT, PAGEDOWN, PAGEUP, RIGHT, Set, TAB, UP, _to_ascii, activating, dragRange, eventChar, getDataProperty, getEvents, getNodeData, getUserData, htmlForNode, idCounter, imbeddedBoundary, indexNode, insertAfterSplit, insertInSplit, isAlphabetic, keyFuncs, maxLastKeys, modifiers, preservingSelection, replacements, runEvent, sameCharacter, selectRange, shiftKey, shiftUps, spaces, specialKeys, wrapDiag,
  indexOf = [].indexOf;

import {
  DOMCursor
} from './domCursor.js';

import {
  FingerTree
} from './fingertree.js';

({selectRange} = DOMCursor);

({Set} = Immutable);

imbeddedBoundary = /.\b./;

maxLastKeys = 4;

BS = 8;

ENTER = 13;

DEL = 46;

TAB = 9;

LEFT = 37;

UP = 38;

RIGHT = 39;

DOWN = 40;

HOME = 36;

END = 35;

PAGEUP = 33;

PAGEDOWN = 34;

specialKeys = {};

specialKeys[TAB] = 'TAB';

specialKeys[ENTER] = 'ENTER';

specialKeys[BS] = 'BS';

specialKeys[DEL] = 'DEL';

specialKeys[LEFT] = 'LEFT';

specialKeys[RIGHT] = 'RIGHT';

specialKeys[UP] = 'UP';

specialKeys[DOWN] = 'DOWN';

specialKeys[PAGEUP] = 'PAGEUP';

specialKeys[PAGEDOWN] = 'PAGEDOWN';

specialKeys[HOME] = 'HOME';

specialKeys[END] = 'END';

// Key funcs
// ---------

// Basic functions used by [defaultBindings](#defaultBindings)
export var useEvent = function(e) {
  e.preventDefault();
  return e.stopPropagation();
};

keyFuncs = {
  backwardChar: function(editor, e, r) {
    useEvent(e);
    editor.moveSelectionBackward(r);
    return false;
  },
  forwardChar: function(editor, e, r) {
    useEvent(e);
    editor.moveSelectionForward(r);
    return false;
  },
  previousLine: function(editor, e, r) {
    useEvent(e);
    editor.moveSelectionUp(r);
    return false;
  },
  nextLine: function(editor, e, r) {
    useEvent(e);
    editor.moveSelectionDown(r);
    return false;
  },
  stabilizeCursor: function(editor, e, r) {
    setTimeout((function() {
      return editor.domCursorForCaret().moveCaret();
    }), 1);
    return false;
  }
};

// <a name="defaultBindings"></a>Default key bindings
// --------------------------------------------------

// These are the default bindings.  You can set the editor's bindings
// property to this or your own object (which can inherit from this, of
// course.)
export var defaultBindings = {
  //'C-S': keyFuncs.save
  'C-Z': function() {
    return alert('UNDO not supported yet');
  },
  'C-S-Z': function() {
    return alert('REDO not supported yet');
  },
  'C-Y': function() {
    return alert('REDO not supported yet');
  },
  'UP': keyFuncs.previousLine,
  'DOWN': keyFuncs.nextLine,
  'LEFT': keyFuncs.backwardChar,
  'RIGHT': keyFuncs.forwardChar,
  'HOME': keyFuncs.stabilizeCursor,
  'END': keyFuncs.stabilizeCursor,
  'C-HOME': keyFuncs.stabilizeCursor,
  'C-END': keyFuncs.stabilizeCursor
};

//'TAB': keyFuncs.expandTemplate
//'C-C C-C': keyFuncs.swapMarkup
//'M-C': keyFuncs.execute
//'C-F': keyFuncs.forwardChar
//'C-B': keyFuncs.backwardChar
//'C-P': keyFuncs.previousLine
//'C-N': keyFuncs.nextLine
//'C-X C-F': keyFuncs.save
dragRange = null;

// `idCounter`: id number for next created block
idCounter = 0;

// Observable class
// ================
export var Observable = class Observable {
  constructor() {
    this.listeners = {};
    this.suppressingTriggers = false;
  }

  on(type, callback) {
    if (typeof type === 'object') {
      for (type in type) {
        callback = type[type];
        this.on(type(callback));
      }
    } else {
      if (!this.listeners[type]) {
        this.listeners[type] = [];
      }
      this.listeners[type].push(callback);
    }
    return this;
  }

  off(type, callback) {
    var callbackType;
    if (typeof type === 'object') {
      for (callbackType in type) {
        callback = type[callbackType];
        this.off(callbackType, callback);
      }
    } else {
      if (this.listeners[type]) {
        this.listeners[type] = this.listeners[type].filter(function(l) {
          return l !== callback;
        });
      }
    }
    return this;
  }

  trigger(type, ...args) {
    var j, len1, listener, ref, results1;
    if (!this.suppressingTriggers) {
      ref = this.listeners[type] || [];
      results1 = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        listener = ref[j];
        results1.push(listener(...args));
      }
      return results1;
    }
  }

  suppressTriggers(func) {
    var oldSuppress;
    oldSuppress = this.suppressingTriggers;
    this.suppressingTriggers = true;
    try {
      return func();
    } finally {
      this.suppressingTriggers = oldSuppress;
    }
  }

};

// FeatherJQ class
// ===============
// A featherweight JQuery replacement.  Users can use set$ to make it use
// the real jQuery, like this: `set$($, (obj)-> obj instanceof $)`
export var FeatherJQ = class FeatherJQ extends Array {
  constructor(...specs) {
    var j, len1, results, spec;
    results = [];
    results.__proto__ = FeatherJQ.prototype;
    for (j = 0, len1 = specs.length; j < len1; j++) {
      spec = specs[j];
      results.pushResult(spec);
    }
    return results;
  }

  find(sel) {
    var j, len1, len2, node, o, ref, ref1, result, results;
    results = $();
    ref = this;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      if (node.querySelectorAll != null) {
        ref1 = node.querySelectorAll(sel);
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          result = ref1[o];
          results.push(result);
        }
      }
    }
    return results;
  }

  attr(name, value) {
    var j, len1, node, ref;
    if (value != null) {
      ref = this;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        node = ref[j];
        node.setAttribute(name, value);
      }
      return this;
    } else {
      return typeof this[0] === "function" ? this[0](getAttribute(name)) : void 0;
    }
  }

  prop(name, value) {
    var j, len1, node, ref, ref1;
    if (value != null) {
      ref = this;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        node = ref[j];
        node[name] = value;
      }
      return this;
    } else {
      return (ref1 = this[0]) != null ? ref1[name] : void 0;
    }
  }

  closest(sel) {
    var j, len1, n, node, ref, result;
    result = $();
    ref = this;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      if (n = (node.closest != null ? node : node.parentNode).closest(sel)) {
        result.push(n);
      }
    }
    return result;
  }

  is(sel) {
    var j, len1, node, ref;
    ref = this;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      if (typeof node.matches === "function" ? node.matches(sel) : void 0) {
        return true;
      }
    }
    return false;
  }

  parent() {
    var j, len1, node, p, ref, result;
    result = $();
    ref = this;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      if (p = node.parentNode) {
        result.push(p);
      }
    }
    return result;
  }

  data(key, value) {
    var j, len1, node, ref, ref1, results1;
    if (!key) {
      return getUserData(this[0], true);
    } else if (value == null) {
      return (ref = getUserData(this[0], true)) != null ? ref[key] : void 0;
    } else {
      ref1 = this;
      results1 = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        node = ref1[j];
        getUserData(node, true)[key] = value;
        results1.push(this);
      }
      return results1;
    }
  }

  on(evtType, func) {
    var evt, j, len1, node, ref, results1;
    ref = this;
    results1 = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      evt = getEvents(node);
      if (!evt[evtType]) {
        node.addEventListener(evtType, runEvent);
        evt[evtType] = [];
      }
      results1.push(evt[evtType].push(func));
    }
    return results1;
  }

  off(evtType, func) {
    var events, h, j, len1, node, ref, results1;
    ref = this;
    results1 = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      node = ref[j];
      if (!(events = getEvents(node) && events[evtType])) {
        continue;
      }
      events = func ? (function() {
        var len2, o, ref1, results2;
        ref1 = events[evtType];
        results2 = [];
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          h = ref1[o];
          if (h !== func) {
            results2.push(h);
          }
        }
        return results2;
      })() : [];
      if (!events.length) {
        results1.push(delete events[evtType]);
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  }

  pushResult(spec) {
    var div, err;
    if (typeof spec === 'string') {
      try {
        return this.push(...document.querySelectorAll(spec));
      } catch (error) {
        err = error;
        div = document.createElement('div');
        div.innerHTML = html;
        return this.push(...div.children);
      }
    //else if spec instanceof FeatherJQ then @push spec...
    } else if (typeof spec === 'object' && spec.nodeName) {
      return this.push(spec);
    } else if (typeof spec === 'object' && spec.prop) {
      return this.push(...spec);
    } else {
      return this.push(spec);
    }
  }

};

export var $ = FeatherJQ;

export var is$ = function(obj) {
  return obj instanceof FeatherJQ || (obj.prop && obj.attr);
};

export var set$ = function(new$, is$Func) {
  $ = new$;
  return is$ = is$Func || is$;
};

FJQData = new WeakMap();

runEvent = function(evt) {
  var handler, j, len1, ref, ref1;
  ref1 = (ref = getEvents(evt.currentTarget)) != null ? ref : [];
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    handler = ref1[j];
    handler(evt);
  }
  return null;
};

getNodeData = function(node, create) {
  if (create || FJQData.has(node)) {
    if (!FJQData.has(node)) {
      FJQData.set(node, {});
    }
    return FJQData.get(node);
  }
};

getDataProperty = function(node, prop, create) {
  var d;
  if (d = getNodeData(node, create)) {
    if (!d[prop]) {
      d[prop] = {};
    }
    return d[prop];
  }
};

getUserData = function(node, create) {
  if (node) {
    return getDataProperty(node, 'userData', create);
  }
};

getEvents = function(node, create) {
  return getDataProperty(node, 'events', create);
};

$.ajax = function({url, success, data}) {
  var xhr;
  xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      return success(xhr.responseText);
    }
  };
  xhr.open((data ? 'POST' : 'GET'), url, true);
  return xhr.send(data);
};

$.get = function(url, success) {
  return $.ajax({url, success});
};


  // LeisureEditCore class
// =====================
// Events:
//   `moved`: the cursor moved
export var LeisureEditCore = class LeisureEditCore extends Observable {
  constructor(node1, options) {
    super();
    this.node = node1;
    this.options = options;
    this.editing = false;
    this.node.attr('contenteditable', 'true').attr('spellcheck', 'false');
    this.node.data().editor = this;
    this.curKeyBinding = this.prevKeybinding = null;
    this.bind();
    this.lastKeys = [];
    this.modCancelled = false;
    this.clipboardKey = null;
    this.ignoreModCheck = 0;
    this.movementGoal = null;
    this.options.setEditor(this);
    this.currentSelectedBlock = null;
  }

  editWith(func) {
    this.editing = true;
    try {
      return func();
    } finally {
      this.editing = false;
    }
  }

  savePosition(func) {
    var pos;
    if (this.editing) {
      return func();
    } else {
      pos = this.getSelectedDocRange();
      try {
        return func();
      } catch (error) {
        return this.selectDocRange(pos);
      }
    }
  }

  getCopy(id) {
    return copyBlock(this.options.getBlock(id));
  }

  getText() {
    return this.options.getText();
  }

  blockForCaret() {
    return this.blockForNode(this.domCursorForCaret().node);
  }

  blockForNode(node) {
    return this.options.getBlock(this.options.idForNode(node));
  }

  blockNodeForNode(node) {
    return this.options.nodeForId(this.options.idForNode(node));
  }

  blockTextForNode(node) {
    var next, nextPos, parent, ref;
    parent = this.blockNodeForNode(node)[0];
    if (next = (ref = this.options.getBlock(this.options.idForNode(node))) != null ? ref.next : void 0) {
      nextPos = this.domCursorForText(this.options.nodeForId(next), 0);
      return this.domCursorForText(parent, 0, parent).getTextTo(nextPos);
    } else {
      return this.domCursorForText(parent, 0, parent).getText();
    }
  }

  verifyNode(node) {
    if (typeof node === 'string') {
      node = this.options.nodeForId(node);
    }
    return this.blockTextForNode(node) === this.options.getBlock(this.options.idForNode(node)).text;
  }

  verifyAllNodes() {
    var badIds, block, node;
    badIds = [];
    block = this.options.getBlock(this.options.getFirst());
    while (block) {
      if ((node = this.options.nodeForId(block._id)[0]) && !this.verifyNode(node)) {
        badIds.push(block._id);
      }
      block = this.options.getBlock(block.next);
    }
    if (badIds.length) {
      return badIds;
    }
  }

  domCursor(node, pos) {
    if (is$(node)) {
      node = node[0];
      pos = pos != null ? pos : 0;
    } else if (node instanceof DOMCursor) {
      pos = node.pos;
      node = node.node;
    }
    return this.options.domCursor(node, pos);
  }

  domCursorForText(node, pos, parent) {
    var c;
    c = this.domCursor(node, pos).filterTextNodes().firstText();
    if (parent != null) {
      return c.filterParent(parent);
    } else {
      return c;
    }
  }

  domCursorForTextPosition(parent, pos, contain) {
    return this.domCursorForText(parent, 0, (contain ? parent : void 0)).mutable().forwardChars(pos, contain).adjustForNewline();
  }

  domCursorForCaret() {
    var n, r, sel;
    sel = getSelection();
    if (sel.type === 'None') {
      return DOMCursor.emptyDOMCursor;
    } else {
      r = sel.getRangeAt(0);
      n = this.domCursor(r.startContainer, r.startOffset).mutable().filterVisibleTextNodes().filterParent(this.node[0]).firstText();
      if (n.isEmpty() || n.pos <= n.node.length) {
        return n;
      } else {
        return n.next();
      }
    }
  }

  getTextPosition(parent, target, pos) {
    var targ;
    if (parent) {
      targ = this.domCursorForText(target, pos);
      if (!this.options.getContainer(targ.node)) {
        targ = targ.prev();
      }
      return this.domCursorForText(parent, 0, parent).mutable().countChars(targ.node, targ.pos);
    } else {
      return -1;
    }
  }

  loadURL(url) {
    return $.get(url, (text) => {
      return this.options.load(url, text);
    });
  }

  domCursorForDocOffset(dOff) {
    var bOff, node;
    bOff = this.options.blockOffsetForDocOffset(dOff);
    node = this.options.nodeForId(bOff.block);
    return this.domCursorForText(node, 0, this.node[0]).mutable().forwardChars(bOff.offset);
  }

  docOffsetForCaret() {
    var range, s;
    s = getSelection();
    if (s.type === 'None') {
      return -1;
    } else {
      range = s.getRangeAt(0);
      return this.docOffset(range.startContainer, range.startOffset);
    }
  }

  docOffsetForBlockOffset(block, offset) {
    return this.options.docOffsetForBlockOffset(block, offset);
  }

  docOffset(node, offset) {
    var startHolder;
    if (node instanceof Range) {
      offset = node.startOffset;
      node = node.startContainer;
    } else if (node instanceof DOMCursor) {
      offset = node.pos;
      node = node.node;
    }
    if (startHolder = this.options.getContainer(node)) {
      return this.options.docOffsetForBlockOffset(this.options.idForNode(startHolder), this.getTextPosition(startHolder, node, offset));
    }
  }

  getSelectedDocRange() {
    var end, length, range, s, start;
    s = getSelection();
    if (s.type === 'None') {
      return {
        type: 'None'
      };
    } else {
      range = s.getRangeAt(0);
      if (start = this.docOffset(range.startContainer, range.startOffset)) {
        if (s.type === 'Caret') {
          length = 0;
        } else {
          end = this.docOffset(range.endContainer, range.endOffset);
          length = Math.abs(start - end);
          start = Math.min(start, end);
        }
        return {
          type: s.type,
          start: start,
          length: length,
          scrollTop: this.node[0].scrollTop,
          scrollLeft: this.node[0].scrollLeft
        };
      } else {
        return {
          type: 'None'
        };
      }
    }
  }

  selectDocRange(range) {
    var start;
    if (range.type !== 'None' && !(start = this.domCursorForDocOffset(range.start).save()).isEmpty()) {
      selectRange(start.range(start.mutable().forwardChars(range.length)));
      this.node[0].scrollTop = range.scrollTop;
      return this.node[0].scrollLeft = range.scrollLeft;
    }
  }

  getSelectedBlockRange() {
    var p, s;
    s = getSelection();
    if (s.type !== 'None' && (p = this.blockOffset(s.getRangeAt(0)))) {
      p.type = s.type;
      p.length = this.selectedText(s).length;
      return p;
    } else {
      return {
        type: 'None'
      };
    }
  }

  blockOffset(node, offset) {
    var startHolder;
    if (node instanceof Range) {
      offset = node.startOffset;
      node = node.startContainer;
    } else if (node instanceof DOMCursor) {
      offset = node.pos;
      node = node.node;
    }
    if (startHolder = this.options.getContainer(node)) {
      return {
        block: this.options.getBlock(this.options.idForNode(startHolder)),
        offset: this.getTextPosition(startHolder, node, offset)
      };
    }
  }

  blockRangeForOffsets(start, length) {
    var block, offset;
    ({block, offset} = this.options.getBlockOffsetForPosition(start));
    return {
      block,
      offset,
      length,
      type: length === 0 ? 'Caret' : 'Range'
    };
  }

  replace(e, br, text, select) {
    if (br.type !== 'None') {
      return this.editWith(() => {
        var pos, start;
        start = this.options.docOffsetForBlockOffset(br);
        pos = this.getSelectedDocRange();
        text = text != null ? text : getEventChar(e);
        this.options.replaceText({
          start,
          end: start + br.length,
          text,
          source: 'edit'
        });
        if (select) {
          pos.type = text.length === 0 ? 'Caret' : 'Range';
          pos.length = text.length;
        } else {
          pos.type = 'Caret';
          pos.length = 0;
          pos.start += text.length;
        }
        return this.selectDocRange(pos);
      });
    }
  }

  backspace(event, sel, r) {
    var holderId;
    if (sel.type === 'Range') {
      return this.cutText(event);
    }
    holderId = this.idAtCaret(sel);
    this.currentBlockIds = [holderId];
    return this.handleDelete(event, sel, false);
  }

  del(event, sel, r) {
    var holderId;
    if (sel.type === 'Range') {
      return this.cutText(event);
    }
    holderId = this.idAtCaret(sel);
    this.currentBlockIds = [holderId];
    return this.handleDelete(event, sel, true);
  }

  idAtCaret(sel) {
    return this.options.idForNode(this.options.getContainer(sel.anchorNode));
  }

  selectedText(s) {
    var r;
    r = s.getRangeAt(0);
    if (r.collapsed) {
      return '';
    } else {
      return this.domCursor(r.startContainer, r.startOffset).getTextTo(this.domCursor(r.endContainer, r.endOffset));
    }
  }

  cutText(e) {
    var html, r, sel, text;
    useEvent(e);
    sel = getSelection();
    if (sel.type === 'Range') {
      html = _.map(sel.getRangeAt(0).cloneContents().childNodes, htmlForNode).join('');
      text = this.selectedText(sel);
      this.options.simulateCut({
        html: html,
        text: text
      });
      r = this.getSelectedDocRange();
      this.replace(e, this.getSelectedBlockRange(), '');
      return this.selectDocRange({
        type: 'Caret',
        start: r.start,
        length: 0,
        scrollTop: r.scrollTop,
        scrollLeft: r.scrollLeft
      });
    }
  }

  handleDelete(e, s, forward) {
    var r;
    useEvent(e);
    r = this.getSelectedDocRange();
    if (r.type === 'None' || (r.type === 'Caret' && ((forward && r.start >= this.options.getLength() - 1) || (!forward && r.start === 0)))) {
      return;
    }
    if (r.type === 'Caret') {
      r.length = 1;
      if (!forward) {
        r.start -= 1;
      }
    }
    this.options.replaceText({
      start: r.start,
      end: r.start + r.length,
      text: '',
      source: 'edit'
    });
    return this.selectDocRange({
      type: 'Caret',
      start: r.start,
      length: 0,
      scrollTop: r.scrollTop,
      scrollLeft: r.scrollLeft
    });
  }

  bind() {
    this.bindDragAndDrop();
    this.bindClipboard();
    this.bindMouse();
    return this.bindKeyboard();
  }

  bindDragAndDrop() {
    this.node.on('dragover', (e) => {
      this.options.dragOver(e.originalEvent);
      return true;
    });
    this.node.on('dragenter', (e) => {
      this.options.dragEnter(e.originalEvent);
      return true;
    });
    this.node.on('drop', (e) => {
      var blockId, cutOffset, dr, dropContainer, dropPos, insert, insertOffset, insertText, oe, offset, r, r2, start;
      useEvent(e);
      oe = e.originalEvent;
      oe.dataTransfer.dropEffect = 'move';
      r = document.caretRangeFromPoint(oe.clientX, oe.clientY);
      dropPos = this.domCursor(r.startContainer, r.startOffset).moveCaret();
      dropContainer = this.domCursor(this.options.getContainer(r.startContainer), 0);
      blockId = this.options.idForNode(dropContainer.node);
      offset = dropContainer.countChars(dropPos);
      insertText = oe.dataTransfer.getData('text/plain');
      insert = () => {
        return this.replace(e, {
          type: 'Caret',
          offset,
          block: this.options.getBlock(blockId),
          length: 0
        }, insertText, false);
      };
      if (dragRange) {
        start = this.domCursor(this.options.nodeForId(dragRange.block._id), 0).forwardChars(dragRange.offset);
        r2 = start.range(start.forwardChars(dragRange.length));
        insertOffset = this.options.getPositionForBlock(this.options.getBlock(blockId)) + offset;
        cutOffset = this.options.getPositionForBlock(dragRange.block) + dragRange.offset;
        if ((cutOffset <= insertOffset && insertOffset <= cutOffset + dragRange.length)) {
          useEvent(oe);
          oe.dataTransfer.dropEffect = 'none';
          return;
        }
        dr = dragRange;
        dragRange = null;
        if (insertOffset <= cutOffset) {
          this.replace(e, dr, '', false);
          this.replace(e, this.blockRangeForOffsets(insertOffset, 0), insertText, false);
        } else {
          insert();
          this.replace(e, this.blockRangeForOffsets(cutOffset, dr.length), '', false);
        }
      } else {
        insert();
      }
      return true;
    });
    this.node.on('dragstart', (e) => {
      var clipboard, sel;
      sel = getSelection();
      if (sel.type === 'Range') {
        dragRange = this.getSelectedBlockRange();
        clipboard = e.originalEvent.dataTransfer;
        clipboard.setData('text/html', _.map(sel.getRangeAt(0).cloneContents().childNodes, htmlForNode).join(''));
        clipboard.setData('text/plain', this.selectedText(sel));
        clipboard.effectAllowed = 'copyMove';
        clipboard.dropEffect = 'move';
      }
      return true;
    });
    return this.node[0].addEventListener('dragend', (e) => {
      var dr, sel;
      if (dr = dragRange) {
        dragRange = null;
        if (e.dataTransfer.dropEffect === 'move') {
          useEvent(e);
          sel = this.getSelectedDocRange();
          this.replace(e, dr, '');
          return this.selectDocRange(sel);
        }
      }
    });
  }

  bindClipboard() {
    this.node.on('cut', (e) => {
      var clipboard, sel;
      useEvent(e);
      sel = getSelection();
      if (sel.type === 'Range') {
        clipboard = e.originalEvent.clipboardData;
        clipboard.setData('text/html', _.map(sel.getRangeAt(0).cloneContents().childNodes, htmlForNode).join(''));
        clipboard.setData('text/plain', this.selectedText(sel));
        return this.replace(e, this.getSelectedBlockRange(), '');
      }
    });
    this.node.on('copy', (e) => {
      var clipboard, sel;
      useEvent(e);
      sel = getSelection();
      if (sel.type === 'Range') {
        clipboard = e.originalEvent.clipboardData;
        clipboard.setData('text/html', _.map(sel.getRangeAt(0).cloneContents().childNodes, htmlForNode).join(''));
        return clipboard.setData('text/plain', this.selectedText(sel));
      }
    });
    return this.node.on('paste', (e) => {
      useEvent(e);
      return this.replace(e, this.getSelectedBlockRange(), e.originalEvent.clipboardData.getData('text/plain'), false);
    });
  }

  bindMouse() {
    this.node.on('mousedown', (e) => {
      var end, s, start, txt;
      if (this.lastDragRange && e.originalEvent.detail === 2) {
        this.dragRange = this.lastDragRange;
        console.log("double click");
        start = this.domCursor(this.dragRange).mutable();
        end = start.copy();
        txt = start.char();
        while (true) {
          start.backwardChar();
          if (!start.isEmpty() && start.type === 'text') {
            txt = start.char() + txt;
          }
          if (start.isEmpty() || start.type !== 'text' || txt.match(imbeddedBoundary)) {
            //start.forwardChar()
            break;
          }
        }
        txt = end.char();
        while (true) {
          end.forwardChar();
          if (!end.isEmpty() && end.type === 'text') {
            txt += end.char();
          }
          if (end.isEmpty() || end.type !== 'text' || txt.match(imbeddedBoundary)) {
            end.backwardChar();
            break;
          }
        }
        s = getSelection();
        s.removeAllRanges();
        this.dragRange.setStart(start.node, start.pos);
        this.dragRange.setEnd(end.node, end.pos);
        s.addRange(this.dragRange);
        e.preventDefault();
      } else if (this.dragRange = this.getAdjustedCaretRange(e)) {
        this.domCursor(this.dragRange).moveCaret();
        e.preventDefault();
      }
      setTimeout((() => {
        return this.trigger('moved', this);
      }), 1);
      return this.setCurKeyBinding(null);
    });
    this.node.on('mouseup', (e) => {
      this.lastDragRange = this.dragRange;
      this.dragRange = null;
      this.adjustSelection(e);
      return this.trigger('moved', this);
    });
    return this.node.on('mousemove', (e) => {
      var r2, s;
      if (this.dragRange) {
        s = getSelection();
        s.removeAllRanges();
        s.addRange(this.dragRange);
        r2 = this.getAdjustedCaretRange(e, true);
        s.extend(r2.startContainer, r2.startOffset);
        return e.preventDefault();
      }
    });
  }

  getAdjustedCaretRange(e, returnUnchanged) {
    var r, r2, rect1, rect2;
    r = document.caretRangeFromPoint(e.clientX, e.clientY);
    r2 = this.domCursor(r).backwardChar().range();
    rect1 = r.getBoundingClientRect();
    rect2 = r2.getBoundingClientRect();
    if (rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect2.left < rect1.left && e.clientX <= (rect1.left + rect2.left) / 2) {
      return r2;
    } else if (returnUnchanged) {
      return r;
    }
  }

  bindKeyboard() {
    this.node.on('keyup', (e) => {
      return this.handleKeyup(e);
    });
    this.node.on('keydown', (e) => {
      var bound, c, checkMod, r, s;
      this.modCancelled = false;
      c = eventChar(e);
      if (!this.addKeyPress(e, c)) {
        return;
      }
      s = getSelection();
      r = s.rangeCount > 0 && s.getRangeAt(0);
      this.currentBlockIds = this.blockIdsForSelection(s, r);
      [bound, checkMod] = this.findKeyBinding(e, r);
      if (bound) {
        return this.modCancelled = !checkMod;
      } else {
        this.modCancelled = false;
        if (c === ENTER) {
          return this.enter(e);
        } else if (c === BS) {
          useEvent(e);
          return this.backspace(e, s, r);
        } else if (c === DEL) {
          useEvent(e);
          return this.del(e, s, r);
        } else if ((modifyingKey(c, e)) && !isAlphabetic(e)) {
          this.char = getEventChar(e);
          return this.keyPress(e);
        }
      }
    });
    return this.node.on('keypress', (e) => {
      if (!e.altKey && !e.metaKey && !e.ctrlKey) {
        return this.keyPress(e);
      }
    });
  }

  enter(e) {
    useEvent(e);
    return this.replace(e, this.getSelectedBlockRange(), '\n', false);
  }

  keyPress(e) {
    useEvent(e);
    return this.replace(e, this.getSelectedBlockRange(), null, false);
  }

  blockIdsForSelection(sel, r) {
    var blocks, cont, cur, end;
    if (!sel) {
      sel = getSelection();
    }
    if (sel.rangeCount === 1) {
      if (!r) {
        r = sel.getRangeAt(0);
      }
      blocks = (cont = this.options.getContainer(r.startContainer)) ? [this.options.idForNode(cont)] : [];
      if (!(r != null ? r.collapsed : void 0)) {
        cur = blocks[0];
        end = this.options.idForNode(this.options.getContainer(r.endContainer));
        while (cur && cur !== end) {
          if (cur = (this.getCopy(cur)).next) {
            blocks.push(cur);
          }
        }
      }
      return blocks;
    }
  }

  setCurKeyBinding(f) {
    this.prevKeybinding = this.curKeyBinding;
    return this.curKeyBinding = f;
  }

  addKeyPress(e, c) {
    var i, j, notShift, ref;
    if (notShift = !shiftKey(c)) {
      e.DE_editorShiftkey = true;
      this.lastKeys.push(modifiers(e, c));
      while (this.lastKeys.length > maxLastKeys) {
        this.lastKeys.shift();
      }
      this.keyCombos = new Array(maxLastKeys);
      for (i = j = 0, ref = Math.min(this.lastKeys.length, maxLastKeys); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        this.keyCombos[i] = this.lastKeys.slice(this.lastKeys.length - i - 1, this.lastKeys.length).join(' ');
      }
      this.keyCombos.reverse();
    }
    return notShift;
  }

  findKeyBinding(e, r) {
    var f, j, k, len1, ref;
    ref = this.keyCombos;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      if (f = this.options.bindings[k]) {
        this.lastKeys = [];
        this.keyCombos = [];
        this.setCurKeyBinding(f);
        return [true, f(this, e, r)];
      }
    }
    this.setCurKeyBinding(null);
    return [false];
  }

  handleKeyup(e) {
    if (this.ignoreModCheck = this.ignoreModCheck) {
      this.ignoreModCheck--;
    }
    if (this.clipboardKey || (!e.DE_shiftkey && !this.modCancelled && modifyingKey(eventChar(e), e))) {
      this.options.keyUp();
      return this.clipboardKey = null;
    }
  }

  adjustSelection(e) {
    var pos, r, s;
    if (e.detail === 1) {
      return;
    }
    s = getSelection();
    if (s.type === 'Range') {
      r = s.getRangeAt(0);
      pos = this.domCursor(r.endContainer, r.endOffset).mutable().filterVisibleTextNodes().firstText();
      while (!pos.isEmpty() && pos.node !== r.startContainer && pos.node.data.trim() === '') {
        pos = pos.prev();
      }
      while (!pos.isEmpty() && pos.pos > 0 && pos.node.data[pos.pos - 1] === ' ') {
        pos.pos--;
      }
      if ((pos.node !== r.startContainer || pos.pos > r.startOffset) && (pos.node !== r.endContainer || pos.pos < r.endOffset)) {
        r.setEnd(pos.node, pos.pos);
        return selectRange(r);
      }
    }
  }

  moveSelectionForward() {
    return this.showCaret(this.moveForward());
  }

  moveSelectionDown() {
    return this.showCaret(this.moveDown());
  }

  moveSelectionBackward() {
    return this.showCaret(this.moveBackward());
  }

  moveSelectionUp() {
    return this.showCaret(this.moveUp());
  }

  showCaret(pos) {
    if (pos.isEmpty()) {
      pos = pos.prev();
    }
    pos = this.domCursorForCaret();
    pos.moveCaret();
    (pos.node.nodeType === pos.node.TEXT_NODE ? pos.node.parentNode : pos.node).scrollIntoViewIfNeeded();
    return this.trigger('moved', this);
  }

  moveForward() {
    var offset, pos, r, sel, start;
    sel = getSelection();
    offset = sel.type === 'None' ? 0 : (r = sel.getRangeAt(0), offset = r.endContainer === r.startContainer ? this.docOffset(r.endContainer, Math.max(r.startOffset, r.endOffset)) : this.docOffset(r.endContainer, r.endOffset));
    start = pos = this.domCursorForCaret().firstText().save();
    if (!pos.isEmpty() && this.options.isValidDocOffset(offset) && (this.domCursorForCaret().firstText().equals(start) || pos.isCollapsed())) {
      pos = this.domCursorForDocOffset(offset);
      while (!pos.isEmpty() && (this.domCursorForCaret().firstText().equals(start) || pos.isCollapsed())) {
        if (pos.isCollapsed()) {
          pos.next().moveCaret();
        } else {
          pos.forwardChars(1).moveCaret();
        }
      }
    }
    if (pos.isEmpty()) {
      offset = this.options.getLength() - 1;
      pos = this.domCursorForDocOffset(offset).firstText();
      while (!pos.isEmpty() && pos.isCollapsed()) {
        pos = this.domCursorForDocOffset(--offset);
      }
    } else if (!this.options.isValidDocOffset(offset)) {
      pos = start;
    }
    return pos.moveCaret();
  }

  moveBackward() {
    var offset, pos, r, sel, start;
    sel = getSelection();
    offset = sel.type === 'None' ? 0 : (r = sel.getRangeAt(0), offset = r.endContainer === r.startContainer ? this.docOffset(r.endContainer, Math.min(r.startOffset, r.endOffset)) : this.docOffset(r.startContainer, r.startOffset));
    start = pos = this.domCursorForCaret().firstText().save();
    if (!pos.isEmpty() && (this.domCursorForCaret().firstText().equals(start) || pos.isCollapsed())) {
      pos = this.domCursorForDocOffset(offset);
      while (!pos.isEmpty() && (this.domCursorForCaret().firstText().equals(start) || pos.isCollapsed())) {
        if (pos.isCollapsed()) {
          pos.prev();
        } else {
          pos.backwardChar().moveCaret();
        }
      }
    }
    if (pos.isEmpty()) {
      offset = 0;
      pos = this.domCursorForDocOffset(offset).firstText();
      while (!pos.isEmpty() && pos.isCollapsed()) {
        pos = this.domCursorForDocOffset(++offset);
      }
    }
    return pos.moveCaret();
  }

  firstText() {
    return this.domCursor(this.node, 0).firstText().node;
  }

  moveDown() {
    var docPos, lastPos, line, linePos, lineTop, p, pos, prev, ref;
    linePos = prev = pos = this.domCursorForCaret().save();
    if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
      this.movementGoal = this.options.blockColumn(pos);
      line = 0;
    } else {
      line = (pos.pos === 0 && pos.node === this.firstText() && this.options.blockColumn(pos) < this.movementGoal ? 1 : 0);
    }
    lineTop = posFor(linePos).top;
    lastPos = this.docOffset(pos) - 1;
    while (!(pos = this.moveForward()).isEmpty() && (docPos = this.docOffset(pos)) !== lastPos) {
      lastPos = docPos;
      p = posFor(pos);
      if (lineTop < p.top) {
        line++;
        pos = linePos = p.pos;
        lineTop = p.top;
      }
      if (line === 2) {
        return prev.moveCaret();
      }
      if (line === 1 && this.options.blockColumn(pos) >= this.movementGoal) {
        return this.moveToBestPosition(pos, prev, linePos);
      }
      prev = pos;
    }
    return pos;
  }

  moveUp() {
    var docPos, lastPos, line, linePos, pos, prev, ref;
    linePos = prev = pos = this.domCursorForCaret().save();
    if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
      this.movementGoal = this.options.blockColumn(pos);
    }
    line = 0;
    lastPos = this.options.getLength();
    while (!(pos = this.moveBackward()).isEmpty() && (docPos = this.docOffset(pos)) !== lastPos) {
      lastPos = docPos;
      if (linePos.differentLines(pos)) {
        line++;
        linePos = pos;
      }
      if (line === 2) {
        return prev.moveCaret();
      }
      if (line === 1 && this.options.blockColumn(pos) <= this.movementGoal) {
        return this.moveToBestPosition(pos, prev, linePos);
      }
      prev = pos;
    }
    return pos;
  }

  // `moveToBestPosition(pos, prev, linePos)` tries to move the caret to the best position in the HTML text.  If pos is closer to the goal, return it, otherwise move to prev and return prev.
  moveToBestPosition(pos, prev, linePos) {
    if (linePos === pos || Math.abs(this.options.blockColumn(pos) - this.movementGoal) < Math.abs(this.options.blockColumn(prev) - this.movementGoal)) {
      return pos;
    } else {
      return prev.moveCaret();
    }
  }

  // Set html of an element and evaluate scripts so that document.currentScript is properly set
  setHtml(el, html, outer) {
    var next, par, prev, ref, ref1;
    if (outer) {
      prev = el.previousSibling;
      next = el.nextSibling;
      par = el.parentNode;
      el.outerHTML = html;
      el = (ref = (ref1 = prev != null ? prev.nextSibling : void 0) != null ? ref1 : next != null ? next.previousSibling : void 0) != null ? ref : par != null ? par.firstChild : void 0;
    } else {
      el.innerHTML = html;
    }
    this.activateScripts($(el));
    return el;
  }

  activateScripts(jq) {
    var activating, j, len1, newScript, ref, results1, script, text;
    if (!activating) {
      activating = true;
      try {
        ref = jq.find('script');
        results1 = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          script = ref[j];
          text = !script.type || script.type.toLowerCase() === 'text/javascript' ? script.textContent : script.type.toLowerCase() === 'text/coffeescript' ? CoffeeScript.compile(script.textContent, {
            bare: true
          }) : script.type.toLowerCase() === 'text/literate-coffeescript' ? CoffeeScript.compile(script.textContent, {
            bare: true,
            literate: true
          }) : void 0;
          if (text) {
            newScript = document.createElement('script');
            newScript.type = 'text/javascript';
            if (script.src) {
              newScript.src = script.src;
            }
            newScript.textContent = text;
            this.setCurrentScript(newScript);
            script.parentNode.insertBefore(newScript, script);
            results1.push(script.parentNode.removeChild(script));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      } finally {
        this.setCurrentScript(null);
        activating = false;
      }
    }
  }

  setCurrentScript(script) {
    return LeisureEditCore.currentScript = null;
  }

};

eventChar = function(e) {
  return e.charCode || e.keyCode || e.which;
};

isAlphabetic = function(e) {
  var ref;
  return !e.altKey && !e.ctrlKey && !e.metaKey && ((64 < (ref = eventChar(e)) && ref < 91));
};

export var BasicEditingOptions = (function() {
  // BasicEditingOptions class
  // =========================
  // BasicEditingOptions is an the options base class.

    // Events:
  //   `load`: new text was loaded into the editor

    // Hook methods (required)
  // -----------------------

    // `renderBlock(block) -> [html, next]`: render a block (and potentially its children) and return the HTML and the next blockId if there is one

    //   * Block DOM (DOM for a block) must be a single element with the same id as the block.
  //   * Block DOM may contain nested block DOM.
  //   * each block's DOM should have the same id as the block and have a data-block attribute
  //   * non-editable parts of the DOM should have contenteditable=false
  //   * completely skipped parts should be non-editable and have a data-noncontent attribute

    // Properties of BasicEditingOptions
  // ---------------------------------
  // * `blocks {id -> block}`: block table
  // * `first`: id of first block
  // * `bindings {keys -> binding(editor, event, selectionRange)}`: a map of bindings (can use LeisureEditCore.defaultBindings)

    // Methods of BasicEditingOptions
  // ------------------------------
  // * `getBlock(id) -> block?`: get the current block for id
  // * `getContainer(node) -> Node?`: get block DOM node containing for a node
  // * `getFirst() -> blockId`: get the first block id
  // * `domCursor(node, pos) -> DOMCursor`: return a domCursor that skips over non-content
  // * `keyUp(editor) -> void`: handle keyup after-actions
  // * `topRect() -> rect?`: returns null or the rectangle of a toolbar at the page top
  // * `blockColumn(pos) -> colNum`: returns the start column on the page for the current block
  // * `load(el, text) -> void`: parse text into blocks and replace el's contents with rendered DOM
  class BasicEditingOptions extends Observable {
    renderBlock(block) {
      throw new Error("options.renderBlock(block) is not implemented");
    }

    // Hook methods (optional)
    // -----------------------

      // `simulateCut({html, text})`: The editor calls this when the user hits backspace or delete on selected text.
    simulateCut({html, text}) {}

    // `dragEnter(event)`: alter the drag-enter behavior.  If you want to cancel the drag, for
    // instance, call event.preventDefault() and set the dropEffect to 'none'
    dragEnter(event) {
      if (!event.dataTransfer.getData) {
        useEvent(event);
        return event.dropEffect = 'none';
      }
    }

    // `dragOver(event)`: alter the drag-enter behavior.  If you want to cancel the drag, for
    // instance, call event.preventDefault() and set the dropEffect to 'none'
    dragOver(event) {
      if (!event.dataTransfer.getData) {
        useEvent(event);
        return event.dropEffect = 'none';
      }
    }

    // Main code
    // ---------
    constructor() {
      super();
      this.changeContext = null;
      this.initData();
    }

    setDiagEnabled(flag) {}

    //changeAdvice this, flag,
    //  renderBlocks: diag: wrapDiag
    //  changed: diag: wrapDiag
    //if flag then @diag()
    diag() {
      return this.trigger('diag', this.editor.verifyAllNodes());
    }

    initData() {
      // `blocks {id -> block}`: block table
      this.blocks = {};
      // `first`: id of first block
      return this.first = null;
    }

    // `getFirst() -> blockId`: get the first block id
    getFirst() {
      return this.first;
    }

    nodeForId(id) {
      return $(`#${id}`);
    }

    idForNode(node) {
      return $(node).prop('id');
    }

    setEditor(editor1) {
      this.editor = editor1;
    }

    newId() {
      return this.data.newId();
    }

    // `changeStructure(oldBlocks, newText)`: Compute blocks affected by transforming oldBlocks into newText
    changeStructure(oldBlocks, newText) {
      return computeNewStructure(this, oldBlocks, newText);
    }

    mergeChangeContext(obj) {
      var ref;
      return this.changeContext = _.merge({}, (ref = this.changeContext) != null ? ref : {}, obj);
    }

    clearChangeContext() {
      return this.changeContext = null;
    }

    // `getBlock(id) -> block?`: get the current block for id
    getBlock(id) {
      return this.blocks[id];
    }

    // `blockColumn(pos) -> colNum`: returns the start column on the page for the current block
    blockColumn(pos) {
      return pos.textPosition().left;
    }

    // `topRect() -> rect?`: returns null or the rectangle of a toolbar at the page top
    topRect() {
      return null;
    }

    // `keyUp(editor) -> void`: handle keyup after-actions
    keyUp() {}

    // `domCursor(node, pos) -> DOMCursor`: return a domCursor that skips over non-content
    domCursor(node, pos) {
      return new DOMCursor(node, pos).addFilter(function(n) {
        return (n.hasAttribute('data-noncontent') && 'skip') || true;
      });
    }

    // `getContainer(node) -> Node?`: get block DOM node containing for a node
    getContainer(node) {
      if (this.editor.node[0].compareDocumentPosition(node) & Element.DOCUMENT_POSITION_CONTAINED_BY) {
        return $(node).closest('[data-block]')[0];
      }
    }

    // `loaname, text) -> void`: parse text into blocks and trigger a 'load' event
    load(name, text) {
      this.options.suppressTriggers(() => {
        return this.options.data.suppressTriggers(() => {
          return this.replaceText({
            start: 0,
            end: this.getLength(),
            text,
            source: 'edit'
          });
        });
      });
      this.rerenderAll();
      return this.trigger('load');
    }

    rerenderAll() {
      var result;
      this.editor.setHtml(this.editor.node[0], this.renderBlocks());
      if (result = this.validatePositions()) {
        return console.error(`DISCREPENCY AT POSITION ${result.block._id}, ${result.offset},`);
      }
    }

    blockCount() {
      var b, c;
      c = 0;
      for (b in this.blocks) {
        c++;
      }
      return c;
    }

    blockList() {
      var bl, next, results1;
      next = this.getFirst();
      results1 = [];
      while (next) {
        bl = this.getBlock(next);
        next = bl.next;
        results1.push(bl);
      }
      return results1;
    }

    docOffsetForBlockOffset(bOff, offset) {
      return this.data.docOffsetForBlockOffset(bOff, offset);
    }

    blockOffsetForDocOffset(dOff) {
      return this.data.blockOffsetForDocOffset(dOff);
    }

    getPositionForBlock(block) {
      var cur, offset;
      cur = this.getBlock(this.getFirst());
      offset = 0;
      while (cur._id !== block._id) {
        offset += cur.text.length;
        cur = this.getBlock(cur.next);
      }
      return offset;
    }

    getBlockOffsetForPosition(pos) {
      var cur;
      cur = this.getBlock(this.getFirst());
      while (pos >= cur.text.length) {
        pos -= cur.text.length;
        cur = this.getBlock(cur.next);
      }
      return {
        block: cur,
        offset: pos
      };
    }

    renderBlocks() {
      var html, next, result;
      result = '';
      next = this.getFirst();
      while (next && ([html, next] = this.renderBlock(this.getBlock(next)))) {
        result += html;
      }
      return result;
    }

    getText() {
      var block, text;
      text = '';
      block = this.data.getBlock(this.data.getFirst());
      while (block) {
        text += block.text;
        block = this.data.getBlock(block.next);
      }
      return text;
    }

    getLength() {
      var block, len;
      len = 0;
      block = this.data.getBlock(this.data.getFirst());
      while (block) {
        len += block.text.length;
        block = this.data.getBlock(block.next);
      }
      return len;
    }

    isValidDocOffset(offset) {
      return (0 <= offset && offset <= this.getLength());
    }

    validatePositions() {
      var block, cursor, j, node, offset, ref;
      block = this.data.getBlock(this.data.getFirst());
      while (block) {
        if (node = this.nodeForId(block._id)[0]) {
          cursor = this.domCursor(node, 0).mutable();
          for (offset = j = 0, ref = block.text.length; (0 <= ref ? j < ref : j > ref); offset = 0 <= ref ? ++j : --j) {
            cursor = cursor.firstText();
            if (cursor.isEmpty() || !sameCharacter(cursor.character(), block.text[offset])) {
              return {block, offset};
            }
            cursor.forwardChar();
          }
        }
        block = this.data.getBlock(block.next);
      }
    }

  };

  // `bindings {keys -> binding(editor, event, selectionRange)}`: a map of bindings (can use LeisureEditCore.defaultBindings)
  BasicEditingOptions.prototype.bindings = defaultBindings;

  return BasicEditingOptions;

}).call(this);

spaces = String.fromCharCode(32, 160);

sameCharacter = function(c1, c2) {
  return c1 === c2 || ((indexOf.call(spaces, c1) >= 0) && (indexOf.call(spaces, c2) >= 0));
};

export var computeNewStructure = function(access, oldBlocks, newText) {
  var newBlocks, next, offset, oldText, prev, ref, ref1;
  prev = (ref = (ref1 = oldBlocks[0]) != null ? ref1.prev : void 0) != null ? ref : 0;
  oldBlocks = oldBlocks.slice();
  oldText = null;
  offset = 0;
  if (oldBlocks.length) {
    while (oldText !== newText && (oldBlocks[0].prev || last(oldBlocks).next)) {
      oldText = newText;
      if (prev = access.getBlock(oldBlocks[0].prev)) {
        oldBlocks.unshift(prev);
        newText = prev.text + newText;
        offset += prev.text.length;
      }
      if (next = access.getBlock(last(oldBlocks).next)) {
        oldBlocks.push(next);
        newText += next.text;
      }
      newBlocks = access.parseBlocks(newText);
      if ((!prev || prev.text === newBlocks[0].text) && (!next || next.text === last(newBlocks).text)) {
        break;
      }
    }
  }
  if (!newBlocks) {
    newBlocks = access.parseBlocks(newText);
  }
  while (oldBlocks.length && newBlocks.length && oldBlocks[0].text === newBlocks[0].text) {
    offset -= oldBlocks[0].text.length;
    prev = oldBlocks[0]._id;
    oldBlocks.shift();
    newBlocks.shift();
  }
  while (oldBlocks.length && newBlocks.length && last(oldBlocks).text === last(newBlocks).text) {
    oldBlocks.pop();
    newBlocks.pop();
  }
  return {
    oldBlocks: oldBlocks,
    newBlocks: newBlocks,
    offset: offset,
    prev: prev
  };
};

export var copyBlock = function(block) {
  if (!block) {
    return null;
  } else {
    return Object.assign({}, block);
  }
};

activating = false;

// DataStore
// =========
// An efficient block storage mechanism used by DataStoreEditingOptions

  // Hook methods -- you must define these in your subclass
// ------------------------------------------------------
// * `parseBlocks(text) -> blocks`: parse text into array of blocks -- DO NOT provide _id, prev, or next, they may be overwritten!

  // Events
// ------
// Data objects support the Observable protocol and emit change events in response to data changes

  // `change {adds, updates, removes, oldFirst, old}`

  //   * `oldFirst id`: the previous first (might be the same as the current)
//   * `adds {id->true}`: added items
//   * `updates {id->true}`: updated items
//   * `removes {id->true}`: removed items
//   * `old {id->old block}`: the old items from updates and removes

  // Internal API -- provide/override these if you want to change how the store accesses data
// ----------------------------------------------------------------------------------------

  // * `getFirst()`
// * `setFirst(firstId)`
// * `getBlock(id)`
// * `setBlock(id, block)`
// * `deleteBlock(id)`
// * `eachBlock(func(block [, id]))` -- iterate with func (exit if func returns false)
// * `load(first, blocks)` -- should trigger 'load'

  // External API -- used from outside; alternative data objects must support these methods.
// ---------------------------------------------------------------------------------------

  // In addition to the methods below, data objects must support the Observable protocol and emit
// change events in response to data changes

  // * `getFirst() -> id`: id of the first block
// * `getBlock(id) -> block`: the block for id
// * `load(name, text)`: replace the current document
// * `newId()`:
// * `docOffsetForBlockOffset(args...) -> offset`: args can be a blockOffset or block, offset
// * `blockOffsetForDocOffset(offset) -> blockOffset`: the block offset for a position in the document
// * `suppressTriggers(func) -> func's return value`: suppress triggers while executing func (inherited from Observable)

  // <!-- -->
export var DataStore = class DataStore extends Observable {
  constructor() {
    super();
    this.blocks = {};
    this.blockIndex = this.newBlockIndex();
    this.changeCount = 0;
    this.clearMarks();
    this.markNames = {};
  }

  load(name, text) {
    var block, blockMap, i, j, len1, newBlocks, prev, ref;
    blockMap = {};
    newBlocks = this.parseBlocks(text);
    for (i = j = 0, len1 = newBlocks.length; j < len1; i = ++j) {
      block = newBlocks[i];
      block._id = this.newId();
      blockMap[block._id] = block;
      if (prev = newBlocks[i - 1]) {
        prev.next = block._id;
        block.prev = prev._id;
      }
    }
    this.first = (ref = newBlocks[0]) != null ? ref._id : void 0;
    this.blocks = blockMap;
    return this.makeChanges(() => {
      this.indexBlocks();
      return this.trigger('load');
    });
  }

  // `parseBlocks(text) -> blocks`: parse text into array of blocks -- DO NOT provide _id, prev, or next, they may be overwritten!
  parseBlocks(text) {
    throw new Error("options.parseBlocks(text) is not implemented");
  }

  newBlockIndex(contents) {
    return FingerTree.fromArray(contents != null ? contents : [], {
      identity: function() {
        return {
          ids: Set(),
          length: 0
        };
      },
      measure: function(v) {
        return {
          ids: Set([v.id]),
          length: v.length
        };
      },
      sum: function(a, b) {
        return {
          ids: a.ids.union(b.ids),
          length: a.length + b.length
        };
      }
    });
  }

  newId() {
    return `block${idCounter++}`;
  }

  setDiagEnabled(flag) {}

  //changeAdvice this, flag,
  //  makeChanges: diag: afterMethod ->
  //    if @changeCount == 0 then @diag()
  //if flag then @diag()

    // `getLength() -> number`: the length of the entire document
  getLength() {
    return this.blockIndex.measure().length;
  }

  makeChanges(func) {
    this.changeCount++;
    try {
      return func();
    } finally {
      this.changeCount--;
    }
  }

  clearMarks() {
    return this.marks = FingerTree.fromArray([], {
      identity: function() {
        return {
          names: Set(),
          length: 0
        };
      },
      measure: function(n) {
        return {
          names: Set([n.name]),
          length: n.offset
        };
      },
      sum: function(a, b) {
        return {
          names: a.names.union(b.names),
          length: a.length + b.length
        };
      }
    });
  }

  addMark(name, offset) {
    var first, l, n, rest;
    if (this.markNames[name]) {
      this.removeMark(name);
    }
    this.markNames[name] = true;
    [first, rest] = this.marks.split(function(m) {
      return m.length >= offset;
    });
    l = first.measure().length;
    if (!rest.isEmpty()) {
      n = rest.peekFirst();
      rest = rest.removeFirst().addFirst({
        offset: l + n.offset - offset,
        name: n.name
      });
    }
    return this.marks = first.concat(rest.addFirst({
      offset: offset - l,
      name: name
    }));
  }

  removeMark(name) {
    var first, n, removed, rest;
    if (this.markNames[name]) {
      delete this.markNames[name];
      [first, rest] = this.marks.split(function(m) {
        return m.names.contains(name);
      });
      if (!rest.isEmpty()) {
        removed = rest.peekFirst();
        rest = rest.removeFirst();
        if (!rest.isEmpty()) {
          n = rest.peekFirst();
          rest = rest.removeFirst().addFirst({
            offset: removed.offset + n.offset,
            name: n.name
          });
        }
      }
      return this.marks = first.concat(rest);
    }
  }

  listMarks() {
    var m, n, t;
    m = [];
    t = this.marks;
    while (!t.isEmpty()) {
      n = t.peekFirst();
      m.push(_.defaults({
        location: this.getMarkLocation(n.name)
      }, n));
      t = t.removeFirst();
    }
    return m;
  }

  getMarkLocation(name) {
    var first, rest;
    if (this.markNames[name]) {
      [first, rest] = this.marks.split(function(m) {
        return m.names.contains(name);
      });
      if (!rest.isEmpty()) {
        return first.measure().length + rest.peekFirst().offset;
      }
    }
  }

  blockOffsetForMark(name) {
    var offset;
    if (offset = this.getMarkLocation(name)) {
      return this.blockOffsetForDocOffset(offset);
    }
  }

  floatMarks(start, end, newLength) {
    var first, n, oldLength, rest;
    if (newLength !== (oldLength = end - start)) {
      [first, rest] = this.marks.split(function(m) {
        return m.length > start;
      });
      if (!rest.isEmpty()) {
        n = rest.peekFirst();
        return this.marks = first.concat(rest.removeFirst().addFirst({
          name: n.name,
          offset: n.offset + newLength - oldLength
        }));
      }
    }
  }

  replaceText({start, end, text}) {
    var newBlocks, oldBlocks, prev;
    ({prev, oldBlocks, newBlocks} = this.changesForReplacement(start, end, text));
    if (oldBlocks) {
      this.change(this.changesFor(prev, oldBlocks.slice(), newBlocks.slice()));
      return this.floatMarks(start, end, text.length);
    }
  }

  changesForReplacement(start, end, text) {
    var blocks, change, newBlocks, newText, offset, oldBlocks, prev;
    ({blocks, newText} = this.blockOverlapsForReplacement(start, end, text));
    ({oldBlocks, newBlocks, offset, prev} = change = computeNewStructure(this, blocks, newText));
    if (oldBlocks.length || newBlocks.length) {
      return change;
    } else {
      return {};
    }
  }

  computeRemovesAndNewBlockIds(oldBlocks, newBlocks, newBlockMap, removes) {
    var i, j, len1, len2, newBlock, o, oldBlock, prev, ref;
    ref = oldBlocks.slice(newBlocks.length, oldBlocks.length);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      oldBlock = ref[j];
      removes[oldBlock._id] = oldBlock;
    }
    prev = null;
    for (i = o = 0, len2 = newBlocks.length; o < len2; i = ++o) {
      newBlock = newBlocks[i];
      if (oldBlock = oldBlocks[i]) {
        newBlock._id = oldBlock._id;
        newBlock.prev = oldBlock.prev;
        newBlock.next = oldBlock.next;
      } else {
        newBlock._id = this.newId();
        if (prev) {
          link(prev, newBlock);
        }
      }
      prev = newBlockMap[newBlock._id] = newBlock;
    }
    return prev;
  }

  patchNewBlocks(first, oldBlocks, newBlocks, changes, newBlockMap, removes, prev) {
    var lastBlock, next, oldNext, oldPrev;
    if (!oldBlocks.length && (first = this.getBlock(first))) {
      oldNext = this.getBlock(first.next);
      oldBlocks.unshift(first);
      first = newBlockMap[first._id] = copyBlock(first);
      link(first, newBlocks[0]);
      newBlocks.unshift(first);
      if (oldNext) {
        oldBlocks.push(oldNext);
        oldNext = newBlockMap[oldNext._id] = copyBlock(oldNext);
        link(last(newBlocks), oldNext);
        return newBlocks.push(oldNext);
      }
    } else if (oldBlocks.length !== newBlocks.length) {
      if (!prev && (prev = copyBlock(oldPrev = this.getBlock(oldBlocks[0].prev)))) {
        oldBlocks.unshift(oldPrev);
        newBlocks.unshift(prev);
        newBlockMap[prev._id] = prev;
      }
      lastBlock = last(oldBlocks);
      if (next = copyBlock(oldNext = this.getBlock((lastBlock ? lastBlock.next : this.getFirst())))) {
        oldBlocks.push(oldNext);
        newBlocks.push(next);
        newBlockMap[next._id] = next;
        if (!(next.prev = prev != null ? prev._id : void 0)) {
          changes.first = next._id;
        }
      }
      if (prev) {
        if (!first && ((newBlocks.length && !newBlocks[0].prev) || !oldBlocks.length || !this.getFirst() || removes[this.getFirst()])) {
          changes.first = newBlocks[0]._id;
        }
        return prev.next = next != null ? next._id : void 0;
      }
    }
  }

  changesFor(first, oldBlocks, newBlocks) {
    var changes, newBlockMap, prev, removes;
    newBlockMap = {};
    removes = {};
    changes = {
      removes,
      sets: newBlockMap,
      first: this.getFirst(),
      oldBlocks,
      newBlocks
    };
    prev = this.computeRemovesAndNewBlockIds(oldBlocks, newBlocks, newBlockMap, removes);
    this.patchNewBlocks(first, oldBlocks, newBlocks, changes, newBlockMap, removes, prev);
    this.removeDuplicateChanges(newBlockMap);
    return changes;
  }

  removeDuplicateChanges(newBlockMap) {
    var block, dups, id, oldBlock, results1;
    dups = [];
    for (id in newBlockMap) {
      block = newBlockMap[id];
      if ((oldBlock = this.getBlock(id)) && block.text === oldBlock.text && block.next === oldBlock.next && block.prev === oldBlock.prev) {
        dups.push(id);
      }
    }
    results1 = [];
    for (id in dups) {
      results1.push(delete newBlockMap[id]);
    }
    return results1;
  }

  checkChanges() {
    if (this.changeCount === 0) {
      throw new Error("Attempt to make a change outside of makeChanges");
    }
  }

  setIndex(i) {
    this.checkChanges();
    return this.blockIndex = i;
  }

  getFirst() {
    return this.first;
  }

  setFirst(firstId) {
    return this.first = firstId;
  }

  getBlock(id) {
    return this.blocks[id];
  }

  setBlock(id, block) {
    this.checkChanges();
    this.blocks[id] = block;
    return this.indexBlock(block);
  }

  deleteBlock(id) {
    this.checkChanges();
    delete this.blocks[id];
    return this.unindexBlock(id);
  }

  eachBlock(func) {
    var block;
    block = this.getBlock(this.getFirst());
    while (block && func(block, block._id) !== false) {
      block = this.getBlock(block.next);
    }
    return null;
  }

  indexBlocks() {
    var items;
    this.checkChanges();
    items = [];
    this.eachBlock((block) => {
      return items.push(indexNode(block));
    });
    return this.setIndex(this.newBlockIndex(items));
  }

  splitBlockIndexOnId(id) {
    return this.blockIndex.split(function(m) {
      return m.ids.contains(id);
    });
  }

  splitBlockIndexOnOffset(offset) {
    return this.blockIndex.split(function(m) {
      return m.length > offset;
    });
  }

  indexBlock(block) {
    var first, next, rest, split;
    if (block) {
      this.checkChanges();
      // if the block is indexed, it might be an easy case, otherwise unindex it
      [first, rest] = this.splitBlockIndexOnId(block._id);
      if (!rest.isEmpty() && rest.peekFirst().id === block._id && (next = rest.removeFirst()) && (next.isEmpty() ? !block.next : next.peekFirst().id === block.next) && (first.isEmpty() ? !block.prev : first.peekLast().id === block.prev)) {
        return this.setIndex(first.addLast(indexNode(block)).concat(next));
      }
      if (!rest.isEmpty()) {
        this.unindexBlock(block._id);
      }
      // if next is followed by prev, just insert the block in between
      if ((split = this.fingerNodeOrder(block.prev, block.next)) && _.isArray(split)) {
        [first, rest] = split;
        return this.setIndex(first.addLast(indexNode(block)).concat(rest));
      }
      // repair as much of the index as possible and insert the block
      return this.insertAndRepairIndex(block);
    }
  }

  fingerNode(id) {
    var node;
    return id && (node = this.splitBlockIndexOnId(id)[1].peekFirst()) && node.id === id && node;
  }

  fingerNodeOrder(a, b) {
    var first, ref, ref1, rest, split;
    return !(a || b) || (!a && b ? this.fingerNode(b) : !b && a ? this.fingerNode(a) : ([first, rest] = split = this.splitBlockIndexOnId(b), !first.isEmpty() && !rest.isEmpty() && ((ref = rest.peekFirst()) != null ? ref.id : void 0) === b && ((ref1 = first.peekLast()) != null ? ref1.id : void 0) === a && split));
  }

  // insert block into the index
  // then trace forwards and backwards, repairing along the way
  insertAndRepairIndex(block) {
    var cur, first, mark, node, prev, rest, results1;
    console.warn("REPAIR");
    node = indexNode(block);
    if (block.next) {
      prev = this.getBlock(block.prev);
      if (!block.prev) {
        this.setIndex(this.blockIndex.addFirst(indexNode(block)));
      } else {
        [first, rest] = this.splitBlockIndexOnId(block.next);
        this.setIndex(first.addLast(node).concat(rest));
      }
    } else if (block.prev) {
      [first, rest] = this.splitBlockIndexOnId(block.prev);
      this.setIndex(first.addLast(node).concat(rest));
    } else {
      this.setIndex(this.newBlockIndex([node]));
    }
    mark = block;
    cur = this.getBlock(block.next);
    while (cur && !this.fingerNodeOrder(mark._id, cur._id)) {
      this.unindexBlock(cur._id);
      [first, rest] = this.splitBlockIndexOnId(mark._id);
      this.setIndex(insertAfterSplit(first, indexNode(cur), rest));
      mark = cur;
      cur = this.getBlock(cur.next);
    }
    mark = block;
    cur = this.getBlock(block.prev);
    results1 = [];
    while (cur && !this.fingerNodeOrder(cur._id, mark._id)) {
      this.unindexBlock(cur._id);
      [first, rest] = this.splitBlockIndexOnId(mark._id);
      this.setIndex(insertInSplit(first, indexNode(cur), rest));
      mark = cur;
      results1.push(cur = this.getBlock(cur.prev));
    }
    return results1;
  }

  unindexBlock(id) {
    var first, ref, rest;
    this.checkChanges();
    if (id) {
      [first, rest] = this.splitBlockIndexOnId(id);
      if (((ref = rest.peekFirst()) != null ? ref.id : void 0) === id) {
        return this.setIndex(first.concat(rest.removeFirst()));
      }
    }
  }

  // `docOffsetForBlockOffset(args...) -> offset`: args can be a blockOffset or block, offset
  docOffsetForBlockOffset(block, offset) {
    if (typeof block === 'object') {
      offset = block.offset;
      block = block.block;
    }
    return this.offsetForBlock(block) + offset;
  }

  blockOffsetForDocOffset(offset) {
    var results;
    results = this.splitBlockIndexOnOffset(offset);
    if (!results[1].isEmpty()) {
      return {
        block: results[1].peekFirst().id,
        offset: offset - results[0].measure().length
      };
    } else {
      return {
        block: results[0].peekLast().id,
        offset: results[0].removeLast().measure().length
      };
    }
  }

  offsetForBlock(blockOrId) {
    var id;
    id = typeof blockOrId === 'string' ? blockOrId : blockOrId._id;
    if (this.getBlock(id)) {
      return this.splitBlockIndexOnId(id)[0].measure().length;
    } else {
      return 0;
    }
  }

  blockForOffset(offset) {
    var ref, ref1, results;
    results = this.splitBlockIndexOnOffset(offset);
    return ((ref = (ref1 = results[1]) != null ? ref1.peekFirst() : void 0) != null ? ref : results[0].peekLast).id;
  }

  getDocLength() {
    return this.blockIndex.measure().length;
  }

  getDocSubstring(start, end) {
    var block, endOffset, startOffset, text;
    startOffset = this.blockOffsetForDocOffset(start);
    endOffset = this.blockOffsetForDocOffset(end);
    block = this.getBlock(startOffset.block);
    text = '';
    while (block._id !== endOffset.block) {
      text += block.text;
      block = this.getBlock(block.next);
    }
    if (startOffset.block === endOffset.block) {
      return block.text.substring(startOffset.offset, endOffset.offset);
    } else {
      return text.substring(startOffset.offset) + block.text.substring(0, endOffset.offset);
    }
  }

  // `getText(): -> string`: the text for the entire document
  getText() {
    var text;
    text = '';
    this.eachBlock(function(block) {
      return text += block.text;
    });
    return text;
  }

  check() {
    var bl, first, lastBlock, next, oldBl, prev, seen;
    seen = {};
    first = next = this.getFirst();
    prev = null;
    while (next) {
      prev = next;
      if (seen[next]) {
        throw new Error("cycle in next links");
      }
      seen[next] = true;
      oldBl = bl;
      bl = this.getBlock(next);
      if (!bl) {
        throw new Error(`Next of ${oldBl._id} doesn't exist`);
      }
      next = bl.next;
    }
    this.eachBlock(function(block) {
      if (block._id !== first && !seen[block._id]) {
        throw new Error(`${block._id} not in next chain`);
      }
    });
    seen = {};
    lastBlock = prev;
    while (prev) {
      if (seen[prev]) {
        throw new Error("cycle in prev links");
      }
      seen[prev] = true;
      oldBl = bl;
      bl = this.getBlock(prev);
      if (!bl) {
        throw new Error(`Prev of ${oldBl._id} doesn't exist`);
      }
      prev = bl.prev;
    }
    this.eachBlock(function(block) {
      if (block._id !== lastBlock && !seen[block._id]) {
        throw new Error(`${block._id} not in prev chain`);
      }
    });
    return null;
  }

  blockList() {
    var bl, next, results1;
    next = this.getFirst();
    results1 = [];
    while (next) {
      bl = this.getBlock(next);
      next = bl.next;
      results1.push(bl);
    }
    return results1;
  }

  change(changes) {
    return this.trigger('change', this.makeChange(changes));
  }

  makeChange({first, sets, removes, oldBlocks, newBlocks}) {
    return this.makeChanges(() => {
      var adds, bl, block, err, id, old, result, updates;
      ({adds, updates, old} = result = {
        adds: {},
        updates: {},
        removes,
        old: {},
        sets,
        oldFirst: this.getFirst(),
        first: first,
        oldBlocks,
        newBlocks
      });
      this.setFirst(first);
      for (id in removes) {
        if (bl = this.getBlock(id)) {
          old[id] = bl;
          this.deleteBlock(id);
        }
      }
      for (id in sets) {
        block = sets[id];
        if (bl = this.getBlock(id)) {
          old[id] = bl;
          updates[id] = block;
        } else {
          adds[id] = block;
        }
        this.setBlock(id, block);
      }
      try {
        this.check();
      } catch (error) {
        err = error;
        console.log(err);
      }
      return result;
    });
  }

  indexArray() {
    return treeToArray(this.blockIndex);
  }

  blockArray() {
    var block, blocks;
    blocks = [];
    block = this.getBlock(this.getFirst());
    while (block) {
      blocks.push(block);
      block = this.getBlock(block.next);
    }
    return blocks;
  }

  diag() {
    return this.trigger('diag', this.verifyIndex());
  }

  verifyIndex() {
    var bArray, blockIds, errs, iArray, j, last, len1, node, offset, ref, treeIds;
    iArray = this.indexArray();
    treeIds = _.map(iArray, _.property('id'));
    bArray = this.blockArray();
    blockIds = _.map(bArray, _.property('_id'));
    if (!_.isEqual(treeIds, blockIds)) {
      console.warn(`INDEX ERROR:\nEXPECTED: ${JSON.stringify(blockIds)}\nBUT GOT: ${JSON.stringify(treeIds)}`);
    }
    last = null;
    errs = new BlockErrors();
    for (j = 0, len1 = iArray.length; j < len1; j++) {
      node = iArray[j];
      if (node.length !== ((ref = this.getBlock(node.id)) != null ? ref.text.length : void 0)) {
        errs.badId(node.id, 'bad index length');
      }
    }
    offset = 0;
    this.eachBlock((block) => {
      last = block;
      if (!this.fingerNodeOrder(block.prev, block._id)) {
        errs.badId(block._id, 'bad order');
        console.warn(`NODE ORDER WRONG FOR ${block.prev}, ${block._id}`);
      }
      if (offset !== this.offsetForBlock(block._id)) {
        errs.badId(block._id, "offset");
      }
      if (block.prev && this.blockForOffset(offset - 1) !== block.prev) {
        errs.badId(block._id, "prev");
      }
      if (block.next && this.blockForOffset(offset + block.text.length) !== block.next) {
        errs.badId(block._id, "next");
      }
      return offset += block.text.length;
    });
    return errs.errors();
  }

  blockOverlapsForReplacement(start, end, text) {
    var blocks, cur, endBlock, fullText, offset, startBlock;
    startBlock = this.getBlock(this.blockForOffset(start));
    if (!startBlock && start) {
      startBlock = this.getBlock(this.blockForOffset(start - 1));
    }
    endBlock = this.getBlock(this.blockForOffset(end));
    if (!endBlock && end) {
      endBlock = this.getBlock(this.blockForOffset(end - 1));
    }
    blocks = [startBlock];
    cur = startBlock;
    while (cur !== endBlock && cur.next) {
      blocks.push(cur = this.getBlock(cur.next));
    }
    fullText = blockText(blocks);
    offset = this.offsetForBlock(blocks[0]);
    return {
      blocks: blocks,
      blockText: fullText,
      newText: fullText.substring(0, start - offset) + text + (fullText.substring(end - offset))
    };
  }

};

BlockErrors = class BlockErrors {
  constructor() {
    this.order = [];
    this.ids = {};
  }

  isEmpty() {
    return !this.order.length;
  }

  badId(id, msg) {
    if (!this.ids[id]) {
      this.order.push(id);
      return this.ids[id] = msg;
    } else {
      return this.ids[id] += `, ${msg}`;
    }
  }

  errors() {
    var id, j, len1, ref, results1;
    if (!this.isEmpty()) {
      ref = this.order;
      results1 = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        id = ref[j];
        results1.push([id, `(${this.ids[id]})`]);
      }
      return results1;
    }
  }

};

export var treeToArray = function(tree) {
  var nodes;
  nodes = [];
  while (!tree.isEmpty()) {
    nodes.push(tree.peekFirst());
    tree = tree.removeFirst();
  }
  return nodes;
};

indexNode = function(block) {
  return {
    id: block._id,
    length: block.text.length
  };
};

insertInSplit = function(first, middle, rest) {
  if (first.isEmpty()) {
    return rest.addFirst(middle);
  } else if (rest.isEmpty()) {
    return first.addLast(middle);
  } else {
    return first.addLast(middle).concat(rest);
  }
};

insertAfterSplit = function(first, afterMiddle, rest) {
  var next;
  next = rest.removeFirst().addFirst(afterMiddle);
  if (first.isEmpty()) {
    return next.addFirst(rest.peekFirst());
  } else {
    return first.addLast(rest.peekFirst()).concat(next);
  }
};

// DataStoreEditingOptions
// =======================
export var DataStoreEditingOptions = class DataStoreEditingOptions extends BasicEditingOptions {
  constructor(data1) {
    super();
    this.data = data1;
    this.callbacks = {};
    this.addDataCallbacks({
      change: (changes) => {
        return this.dataChanged(changes);
      },
      load: () => {
        return this.dataLoaded();
      }
    });
  }

  addDataCallbacks(cb) {
    var func, results1, type;
    results1 = [];
    for (type in cb) {
      func = cb[type];
      results1.push(this.data.on(type, this.callbacks[type] = func));
    }
    return results1;
  }

  dataChanged(changes) {
    return preserveSelection(() => {
      return this.changed(changes);
    });
  }

  dataLoaded() {
    return this.trigger('load');
  }

  cleanup() {
    return this.data.off(this.callbacks);
  }

  initData() {}

  load(name, text) {
    return this.data.load(name, text);
  }

  replaceText(repl) {
    return this.data.replaceText(repl);
  }

  getBlock(id) {
    return this.data.getBlock(id);
  }

  getFirst(first) {
    return this.data.getFirst();
  }

  change(changes) {
    if (changes) {
      return this.data.change(changes);
    }
  }

  changed(changes) {
    return this.rerenderAll();
  }

  offsetForBlock(blockOrId) {
    return this.data.offsetForBlock(blockOrId);
  }

};

// Utilities
// =========
export var isEditable = function(n) {
  n = n.nodeType === n.TEXT_NODE ? n.parentNode : n;
  return n.isContentEditable;
};

export var link = function(prev, next) {
  prev.next = next._id;
  return next.prev = prev._id;
};

export var blockText = function(blocks) {
  var block;
  return ((function() {
    var j, len1, results1;
    results1 = [];
    for (j = 0, len1 = blocks.length; j < len1; j++) {
      block = blocks[j];
      results1.push(block.text);
    }
    return results1;
  })()).join('');
};

// getEventChar(e)
// --------------
// adapted from Vega on [StackOverflow](http://stackoverflow.com/a/13127566/1026782)
_to_ascii = {
  '188': '44',
  '109': '45',
  '190': '46',
  '191': '47',
  '192': '96',
  '220': '92',
  '222': '39',
  '221': '93',
  '219': '91',
  '173': '45',
  '187': '61', //IE Key codes
  '186': '59', //IE Key codes
  '189': '45' //IE Key codes
};

shiftUps = {
  "96": "~",
  "49": "!",
  "50": "@",
  "51": "#",
  "52": "$",
  "53": "%",
  "54": "^",
  "55": "&",
  "56": "*",
  "57": "(",
  "48": ")",
  "45": "_",
  "61": "+",
  "91": "{",
  "93": "}",
  "92": "|",
  "59": ":",
  "39": "\"",
  "44": "<",
  "46": ">",
  "47": "?"
};

htmlForNode = function(n) {
  if (n.nodeType === n.TEXT_NODE) {
    return escapeHtml(n.data);
  } else {
    return n.outerHTML;
  }
};

export var getEventChar = function(e) {
  var c, shifton;
  if (e.originalEvent.type === 'keypress') {
    return String.fromCharCode(eventChar(e));
  } else {
    c = e.charCode || e.keyCode || e.which;
    shifton = e.shiftKey || !!(e.modifiers & 4);
    // normalize keyCode
    if (_to_ascii.hasOwnProperty(c)) {
      c = _to_ascii[c];
    }
    if (!shifton && (c >= 65 && c <= 90)) {
      c = String.fromCharCode(c + 32);
    } else if (e.shiftKey && shiftUps.hasOwnProperty(c)) {
      // get shifted keyCode value
      c = shiftUps[c];
    } else {
      c = String.fromCharCode(c);
    }
    return c;
  }
};

shiftKey = function(c) {
  return (15 < c && c < 19);
};

modifiers = function(e, c) {
  var res;
  res = specialKeys[c] || String.fromCharCode(c);
  if (e.altKey) {
    res = "M-" + res;
  }
  if (e.metaKey) {
    res = "M-" + res;
  }
  if (e.ctrlKey) {
    res = "C-" + res;
  }
  if (e.shiftKey) {
    res = "S-" + res;
  }
  return res;
};

export var modifyingKey = function(c, e) {
  return !e.altKey && !e.metaKey && !e.ctrlKey && (((47 < c && c < 58)) || c === 32 || c === ENTER || c === BS || c === DEL || ((64 < c && c < 91)) || ((95 < c && c < 112)) || ((185 < c && c < 193)) || ((218 < c && c < 223))); // [\]' (in order)
};

export var last = function(array) {
  return array.length && array[array.length - 1];
};

export var posFor = function(pos) {
  var p, result;
  if (result = (pos.pos === pos.node.length && pos.node.data[pos.pos - 1] === '\n' && !(p = pos.save().next()).isEmpty() ? p : pos).textPosition()) {
    result.pos = p != null ? p : pos;
    return result;
  }
};

replacements = {
  '<': "&lt;",
  '>': "&gt;",
  '&': "&amp;"
};

export var escapeHtml = function(str) {
  if (typeof str === 'string') {
    return str.replace(/[<>&]/g, function(c) {
      return replacements[c];
    });
  } else {
    return str;
  }
};

export var findEditor = function(node) {
  var ref, target;
  target = $(node);
  while (target.length && !($(target).data().editor instanceof LeisureEditCore)) {
    target = $(target).parent();
  }
  return (ref = target.data()) != null ? ref.editor : void 0;
};

// `preserveSelection` -- restore the current selection after func() completes.  This may
// work better for you than LeisureEditCore.savePosition because it always preserves the
// selection, regardless of the current value of LeisureEditCore.editing.
preservingSelection = null;

export var preserveSelection = function(func) {
  var editor, end, input, num, parent, parentId, start;
  if (preservingSelection) {
    return func(preservingSelection);
  } else if ($(document.activeElement).is('input[input-number]')) {
    num = document.activeElement.getAttribute('input-number');
    parentId = $(document.activeElement).closest('[data-view-block-name]').prop('id');
    input = document.activeElement;
    start = input.selectionStart;
    end = input.selectionEnd;
    try {
      return func({
        type: 'None',
        scrollTop: 0,
        scrollLeft: 0
      });
    } finally {
      parent = $(`#${parentId}`);
      if (input = parent.find(`[input-number='${num}']`)) {
        input.selectionStart = start;
        input.selectionEnd = end;
        input.focus();
      }
    }
  } else if (editor = findEditor(getSelection().anchorNode)) {
    preservingSelection = editor.getSelectedDocRange();
    try {
      return func(preservingSelection);
    } finally {
      editor.selectDocRange(preservingSelection);
      preservingSelection = null;
    }
  } else {
    return func({
      type: 'None',
      scrollTop: 0,
      scrollLeft: 0
    });
  }
};

wrapDiag = function(parent) {
  return function(...args) {
    var r;
    r = parent.apply(this, args);
    this.diag();
    return r;
  };
};

//# sourceMappingURL=editor.js.map

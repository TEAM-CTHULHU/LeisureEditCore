// Generated by CoffeeScript 1.9.1
var BS, BasicEditingOptions, DEL, DOWN, DataStore, DataStoreEditingOptions, END, ENTER, HOME, LEFT, LeisureEditCore, Observable, PAGEDOWN, PAGEUP, RIGHT, TAB, UP, _to_ascii, blockText, defaultBindings, getEventChar, idCounter, isEditable, keyFuncs, last, link, maxLastKeys, modifiers, modifyingKey, root, selectRange, shiftKey, shiftUps, specialKeys,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

selectRange = window.DOMCursor.selectRange;

maxLastKeys = 4;

BS = 8;

ENTER = 13;

DEL = 46;

TAB = 9;

LEFT = 37;

UP = 38;

RIGHT = 39;

DOWN = 40;

HOME = 36;

END = 35;

PAGEUP = 33;

PAGEDOWN = 34;

specialKeys = {};

specialKeys[TAB] = 'TAB';

specialKeys[ENTER] = 'ENTER';

specialKeys[BS] = 'BS';

specialKeys[DEL] = 'DEL';

specialKeys[LEFT] = 'LEFT';

specialKeys[RIGHT] = 'RIGHT';

specialKeys[UP] = 'UP';

specialKeys[DOWN] = 'DOWN';

specialKeys[PAGEUP] = 'PAGEUP';

specialKeys[PAGEDOWN] = 'PAGEDOWN';

specialKeys[HOME] = 'HOME';

specialKeys[END] = 'END';

keyFuncs = {
  backwardChar: function(editor, e, r) {
    e.preventDefault();
    editor.moveSelectionBackward(r);
    return false;
  },
  forwardChar: function(editor, e, r) {
    e.preventDefault();
    editor.moveSelectionForward(r);
    return false;
  },
  previousLine: function(editor, e, r) {
    e.preventDefault();
    editor.moveSelectionUp(r);
    return false;
  },
  nextLine: function(editor, e, r) {
    e.preventDefault();
    editor.moveSelectionDown(r);
    return false;
  }
};

defaultBindings = {
  'C-Z': function() {
    return alert('UNDO not supported yet');
  },
  'C-S-Z': function() {
    return alert('REDO not supported yet');
  },
  'C-Y': function() {
    return alert('REDO not supported yet');
  },
  'UP': keyFuncs.previousLine,
  'DOWN': keyFuncs.nextLine,
  'LEFT': keyFuncs.backwardChar,
  'RIGHT': keyFuncs.forwardChar
};

idCounter = 0;

Observable = (function() {
  function Observable() {
    this.listeners = {};
  }

  Observable.prototype.on = function(type, callback) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    return this.listeners[type].push(callback);
  };

  Observable.prototype.trigger = function() {
    var args, j, len, listener, ref, results, type;
    type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    ref = this.listeners[type] || [];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      results.push(listener.apply(null, args));
    }
    return results;
  };

  return Observable;

})();

LeisureEditCore = (function(superClass) {
  extend(LeisureEditCore, superClass);

  function LeisureEditCore(node1, options) {
    this.node = node1;
    this.options = options;
    LeisureEditCore.__super__.constructor.call(this);
    this.node.attr('contenteditable', 'true').attr('spellcheck', 'false');
    this.curKeyBinding = this.prevKeybinding = null;
    this.bind();
    this.lastKeys = [];
    this.modCancelled = false;
    this.clipboardKey = null;
    this.ignoreModCheck = 0;
    this.movementGoal = null;
    this.options.setEditor(this);
  }

  LeisureEditCore.prototype.getCopy = function(id) {
    var bl, k, old, v;
    if (old = this.options.getBlock(id)) {
      bl = {};
      for (k in old) {
        v = old[k];
        bl[k] = v;
      }
      return bl;
    }
  };

  LeisureEditCore.prototype.getBlockLocation = function() {
    var holder, s;
    s = getSelection();
    if (s.type !== 'None' && (holder = this.options.getContainer(s.anchorNode))) {
      return {
        blockId: this.options.idForNode(holder),
        offset: this.getTextPosition(holder, s.anchorNode, s.anchorOffset)
      };
    } else {
      return {};
    }
  };

  LeisureEditCore.prototype.domCursor = function(node, pos) {
    if (node instanceof jQuery) {
      node = node[0];
      pos = pos != null ? pos : 0;
    }
    return this.options.domCursor(node, pos);
  };

  LeisureEditCore.prototype.domCursorForText = function(node, pos, parent) {
    var c;
    c = this.domCursor(node, pos).filterTextNodes().firstText();
    if (parent != null) {
      return c.filterParent(parent);
    } else {
      return c;
    }
  };

  LeisureEditCore.prototype.domCursorForTextPosition = function(parent, pos, contain) {
    return this.domCursorForText(parent, 0, (contain ? parent : void 0)).mutable().forwardChars(pos, contain).adjustForNewline();
  };

  LeisureEditCore.prototype.domCursorForCaret = function() {
    var n, sel;
    sel = getSelection();
    n = this.domCursor(sel.focusNode, sel.focusOffset).mutable().filterVisibleTextNodes().filterParent(this.node[0]).firstText();
    if (n.isEmpty() || n.pos <= n.node.length) {
      return n;
    } else {
      return n.next();
    }
  };

  LeisureEditCore.prototype.getTextPosition = function(parent, target, pos) {
    var targ;
    if (parent) {
      targ = this.domCursorForText(target, pos);
      if (!this.options.getContainer(targ.node)) {
        targ = targ.prev();
      }
      return this.domCursorForText(parent, 0, parent).mutable().countChars(targ.node, targ.pos);
    } else {
      return -1;
    }
  };

  LeisureEditCore.prototype.loadURL = function(url) {
    return $.get(url, (function(_this) {
      return function(text) {
        return _this.options.load(text);
      };
    })(this));
  };

  LeisureEditCore.prototype.handleInsert = function(e, s, text) {
    var block, blocks, holder, pos;
    e.preventDefault();
    if (s.type === 'Caret') {
      holder = this.options.getContainer(s.anchorNode);
      block = this.getCopy(this.options.idForNode(holder));
      blocks = [block];
      pos = this.getTextPosition(holder, s.anchorNode, s.anchorOffset);
      return this.editBlocks([block], pos, pos, text != null ? text : getEventChar(e), pos + 1);
    } else {
      return setTimeout((function() {
        return alert('Selection not supported yet');
      }), 1);
    }
  };

  LeisureEditCore.prototype.backspace = function(event, sel, r) {
    var holderId;
    holderId = this.options.idForNode(this.options.getContainer(sel.anchorNode));
    this.currentBlockIds = [(this.getCopy(holderId))._id];
    return this.handleDelete(event, sel, false, function(text, pos) {
      return true;
    });
  };

  LeisureEditCore.prototype.del = function(event, sel, r) {
    var holderId;
    holderId = this.options.idForNode(this.options.getContainer(sel.anchorNode));
    this.currentBlockIds = [(this.getCopy(holderId))._id];
    return this.handleDelete(event, sel, true, function(text, pos) {
      return true;
    });
  };

  LeisureEditCore.prototype.handleDelete = function(e, s, forward, delFunc) {
    var bl, block, blocks, c, cont, pos, result, stop;
    e.preventDefault();
    if (s.type === 'Caret') {
      c = this.domCursorForCaret().firstText();
      cont = this.options.getContainer(c.node);
      block = this.getCopy(this.options.idForNode(cont));
      pos = this.getTextPosition(cont, c.node, c.pos);
      result = delFunc(block.text, pos);
      blocks = [];
      if (!result) {
        return this.ignoreModCheck = this.ignoreModCheck || 1;
      } else {
        if (result instanceof Array) {
          pos = result[0], stop = result[1];
        } else {
          pos += forward ? 0 : -1;
          stop = pos + 1;
        }
        if (pos < 0) {
          if (block.prev) {
            blocks.push(bl = this.getCopy(block.prev));
            pos += bl.text.length;
            stop += bl.text.length;
          } else {
            return;
          }
        } else {
          blocks.push(block);
        }
        return this.editBlocks(blocks, pos, stop, '', pos);
      }
    } else {
      return setTimeout((function() {
        return alert('Selection not supported yet');
      }), 1);
    }
  };

  LeisureEditCore.prototype.editBlocks = function(blocks, start, end, newContent) {
    var block, caret, holder, j, len, newBlocks, newText, oldBlock, oldBlocks, oldText, prevBlock, ref;
    caret = start + newContent.length;
    oldText = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = blocks.length; j < len; j++) {
        block = blocks[j];
        results.push(block.text);
      }
      return results;
    })()).join('');
    newText = oldText.substring(0, start) + newContent + oldText.substring(end);
    ref = this.changeStructure(blocks, newText), oldBlocks = ref.oldBlocks, newBlocks = ref.newBlocks, newText = ref.newText;
    if (oldBlocks.length) {
      for (j = 0, len = oldBlocks.length; j < len; j++) {
        oldBlock = oldBlocks[j];
        if (oldBlock._id === blocks[0]._id) {
          break;
        }
        if (oldBlock._id !== blocks[0]._id) {
          caret += oldBlock.text.length;
        }
      }
      if (prevBlock = this.options.getBlock(oldBlocks[0].prev)) {
        caret += prevBlock.text.length;
      }
    }
    this.options.edit(oldBlocks, newBlocks);
    holder = prevBlock ? this.options.nodeForId(prevBlock._id) : this.node[0];
    return this.domCursorForTextPosition(holder, caret).moveCaret();
  };

  LeisureEditCore.prototype.changeStructure = function(oldBlocks, newText) {
    var firstText, lastText, newBlocks, next, nextId, oldText, prev, prevId, ref, ref1;
    oldBlocks = oldBlocks.slice();
    oldText = null;
    while (oldText !== newText) {
      oldText = newText;
      newBlocks = this.options.parseBlocks(newText);
      ref = oldBlocks[0], prevId = ref.prev, firstText = ref.text;
      if (prevId && firstText !== (newBlocks.length ? newBlocks[0].text : '')) {
        oldBlocks.unshift(prev = this.options.getBlock(prevId));
        newText = prev.text + newText;
      }
      ref1 = last(oldBlocks), nextId = ref1.next, lastText = ref1.text;
      if (nextId && lastText !== (newBlocks.length ? last(newBlocks).text : '')) {
        oldBlocks.push(next = this.options.getBlock(nextId));
        newText += next.text;
      }
    }
    while (oldBlocks.length && newBlocks.length && oldBlocks[0].text === newBlocks[0].text) {
      oldBlocks.shift();
      newBlocks.shift();
    }
    while (oldBlocks.length && newBlocks.length && last(oldBlocks).text === last(newBlocks).text) {
      oldBlocks.pop();
      newBlocks.pop();
    }
    return {
      oldBlocks: oldBlocks,
      newBlocks: newBlocks,
      newText: newText
    };
  };

  LeisureEditCore.prototype.bind = function() {
    this.node.on('dragenter', (function(_this) {
      return function(e) {
        e.preventDefault();
        return false;
      };
    })(this));
    this.node.on('dragover', (function(_this) {
      return function(e) {
        e.preventDefault();
        return false;
      };
    })(this));
    this.node.on('dragleave', (function(_this) {
      return function(e) {
        e.preventDefault();
        return false;
      };
    })(this));
    this.node.on('drop', (function(_this) {
      return function(e) {
        e.preventDefault();
        setTimeout((function() {
          return alert('DROP not supported yet');
        }), 1);
        return false;
      };
    })(this));
    this.node.on('cut', (function(_this) {
      return function(e) {
        e.preventDefault();
        return alert('CUT not supported yet');
      };
    })(this));
    this.node.on('copy', (function(_this) {
      return function(e) {
        e.preventDefault();
        return alert('COPY not supported yet');
      };
    })(this));
    this.node.on('paste', (function(_this) {
      return function(e) {
        e.preventDefault();
        return alert('PASTE not supported yet');
      };
    })(this));
    this.node.on('mousedown', (function(_this) {
      return function(e) {
        _this.trigger('moved', _this);
        return _this.setCurKeyBinding(null);
      };
    })(this));
    this.node.on('mouseup', (function(_this) {
      return function(e) {
        _this.adjustSelection(e);
        return _this.trigger('moved', _this);
      };
    })(this));
    this.node.on('keyup', (function(_this) {
      return function(e) {
        return _this.handleKeyup(e);
      };
    })(this));
    return this.node.on('keydown', (function(_this) {
      return function(e) {
        var bound, c, checkMod, r, ref, s;
        _this.modCancelled = false;
        c = e.charCode || e.keyCode || e.which;
        if (!_this.addKeyPress(e, c)) {
          return;
        }
        s = getSelection();
        r = s.rangeCount > 0 && s.getRangeAt(0);
        _this.currentBlockIds = _this.blockIdsForSelection(s, r);
        ref = _this.findKeyBinding(e, r), bound = ref[0], checkMod = ref[1];
        if (bound) {
          return _this.modCancelled = !checkMod;
        } else {
          _this.modCancelled = false;
          if (c === ENTER) {
            return _this.handleInsert(e, s, '\n');
          } else if (c === BS) {
            return _this.backspace(e, s, r);
          } else if (c === DEL) {
            return _this.del(e, s, r);
          } else if (modifyingKey(c, e)) {
            return _this.handleInsert(e, s);
          }
        }
      };
    })(this));
  };

  LeisureEditCore.prototype.blockIdsForSelection = function(sel, r) {
    var blocks, cont, cur, end;
    if (!sel) {
      sel = getSelection();
    }
    if (sel.rangeCount === 1) {
      if (!r) {
        r = sel.getRangeAt(0);
      }
      blocks = (cont = this.options.getContainer(r.startContainer)) ? [this.options.idForNode(cont)] : [];
      if (!(r != null ? r.collapsed : void 0)) {
        cur = blocks[0];
        end = this.options.idForNode(this.options.getContainer(r.endContainer));
        while (cur && cur !== end) {
          if (cur = (this.getCopy(cur)).next) {
            blocks.push(cur);
          }
        }
      }
      return blocks;
    }
  };

  LeisureEditCore.prototype.setCurKeyBinding = function(f) {
    this.prevKeybinding = this.curKeyBinding;
    return this.curKeyBinding = f;
  };

  LeisureEditCore.prototype.addKeyPress = function(e, c) {
    var i, j, notShift, ref;
    if (notShift = !shiftKey(c)) {
      e.DE_editorShiftkey = true;
      this.lastKeys.push(modifiers(e, c));
      while (this.lastKeys.length > maxLastKeys) {
        this.lastKeys.shift();
      }
      this.keyCombos = new Array(maxLastKeys);
      for (i = j = 0, ref = Math.min(this.lastKeys.length, maxLastKeys); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.keyCombos[i] = this.lastKeys.slice(this.lastKeys.length - i - 1, this.lastKeys.length).join(' ');
      }
      this.keyCombos.reverse();
    }
    return notShift;
  };

  LeisureEditCore.prototype.findKeyBinding = function(e, r) {
    var f, j, k, len, ref;
    ref = this.keyCombos;
    for (j = 0, len = ref.length; j < len; j++) {
      k = ref[j];
      if (f = this.options.bindings[k]) {
        this.lastKeys = [];
        this.keyCombos = [];
        this.setCurKeyBinding(f);
        return [true, f(this, e, r)];
      }
    }
    this.setCurKeyBinding(null);
    return [false];
  };

  LeisureEditCore.prototype.handleKeyup = function(e) {
    if (this.ignoreModCheck = this.ignoreModCheck) {
      this.ignoreModCheck--;
    }
    if (this.clipboardKey || (!e.DE_shiftkey && !this.modCancelled && modifyingKey(e.charCode || e.keyCode || e.which, e))) {
      this.options.keyUp();
      return this.clipboardKey = null;
    }
  };

  LeisureEditCore.prototype.adjustSelection = function(e) {
    var pos, r, s;
    if (e.detail === 1) {
      return;
    }
    s = getSelection();
    if (s.type === 'Range') {
      r = s.getRangeAt(0);
      pos = this.domCursor(r.endContainer, r.endOffset).mutable().filterVisibleTextNodes().firstText();
      while (pos.node !== r.startContainer && pos.node.data.trim() === '') {
        pos === pos.prev();
      }
      while (pos.pos > 0 && pos.node.data[pos.pos - 1] === ' ') {
        pos.pos--;
      }
      if ((pos.node !== r.startContainer || pos.pos > r.startOffset) && (pos.node !== r.endContainer || pos.pos < r.endOffset)) {
        r.setEnd(pos.node, pos.pos);
        return selectRange(r);
      }
    }
  };

  LeisureEditCore.prototype.moveSelectionForward = function() {
    return this.showCaret(this.moveForward());
  };

  LeisureEditCore.prototype.moveSelectionDown = function() {
    return this.showCaret(this.moveDown());
  };

  LeisureEditCore.prototype.moveSelectionBackward = function() {
    return this.showCaret(this.moveBackward());
  };

  LeisureEditCore.prototype.moveSelectionUp = function() {
    return this.showCaret(this.moveUp());
  };

  LeisureEditCore.prototype.showCaret = function(pos) {
    if (pos.isEmpty()) {
      pos = pos.prev();
    }
    pos = this.domCursorForCaret();
    pos.moveCaret();
    pos.show(this.options.topRect());
    return this.trigger('moved', this);
  };

  LeisureEditCore.prototype.moveForward = function() {
    var pos, start;
    start = pos = this.domCursorForCaret().firstText().save();
    while (!pos.isEmpty() && this.domCursorForCaret().firstText().equals(start)) {
      pos = pos.forwardChar();
      pos.moveCaret();
    }
    return pos;
  };

  LeisureEditCore.prototype.moveBackward = function() {
    var pos, start;
    start = pos = this.domCursorForCaret().firstText().save();
    while (!pos.isEmpty() && this.domCursorForCaret().firstText().equals(start)) {
      pos = pos.backwardChar();
      pos.moveCaret();
    }
    return pos;
  };

  LeisureEditCore.prototype.moveDown = function() {
    var line, linePos, pos, prev, ref;
    linePos = prev = pos = this.domCursorForCaret().save();
    if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
      this.movementGoal = this.options.blockColumn(pos);
    }
    line = 0;
    while (!(pos = this.moveForward()).isEmpty()) {
      if (linePos.differentLines(pos)) {
        line++;
        linePos = pos;
      }
      if (line === 2) {
        return prev.moveCaret();
      }
      if (line === 1 && this.options.blockColumn(pos) >= this.movementGoal) {
        return this.moveToBestPosition(pos, prev, linePos);
      }
      prev = pos;
    }
    return pos;
  };

  LeisureEditCore.prototype.moveUp = function() {
    var line, linePos, pos, prev, ref;
    linePos = prev = pos = this.domCursorForCaret().save();
    if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
      this.movementGoal = this.options.blockColumn(pos);
    }
    line = 0;
    while (!(pos = this.moveBackward()).isEmpty()) {
      if (linePos.differentLines(pos)) {
        line++;
        linePos = pos;
      }
      if (line === 2) {
        return prev.moveCaret();
      }
      if (line === 1 && this.options.blockColumn(pos) <= this.movementGoal) {
        return this.moveToBestPosition(pos, prev, linePos);
      }
      prev = pos;
    }
    return pos;
  };

  LeisureEditCore.prototype.moveToBestPosition = function(pos, prev, linePos) {
    if (linePos === pos || Math.abs(this.options.blockColumn(pos) - this.movementGoal) < Math.abs(this.options.blockColumn(prev) - this.movementGoal)) {
      return pos;
    } else {
      return prev.moveCaret();
    }
  };

  return LeisureEditCore;

})(Observable);

BasicEditingOptions = (function(superClass) {
  extend(BasicEditingOptions, superClass);

  BasicEditingOptions.prototype.parseBlocks = function(text) {
    throw new Error("options.parseBlocks(text) is not implemented");
  };

  BasicEditingOptions.prototype.renderBlock = function(block) {
    throw new Error("options.renderBlock(block) is not implemented");
  };

  BasicEditingOptions.prototype.edit = function(oldBlocks, newBlocks) {
    throw new Error("options.edit(func) is not implemented");
  };

  function BasicEditingOptions() {
    BasicEditingOptions.__super__.constructor.call(this);
    this.blocks = {};
    this.first = null;
  }

  BasicEditingOptions.prototype.getFirst = function() {
    return this.first;
  };

  BasicEditingOptions.prototype.nodeForId = function(id) {
    return $("#" + id);
  };

  BasicEditingOptions.prototype.idForNode = function(node) {
    return $(node).prop(id);
  };

  BasicEditingOptions.prototype.setEditor = function(editor1) {
    this.editor = editor1;
  };

  BasicEditingOptions.prototype.newId = function() {
    return "block" + (idCounter++);
  };

  BasicEditingOptions.prototype.copyBlock = function(block) {
    var bl, k, v;
    if (!block) {
      return null;
    } else {
      bl = {};
      for (k in block) {
        v = block[k];
        bl[k] = v;
      }
      return bl;
    }
  };

  BasicEditingOptions.prototype.replaceBlocks = function(oldBlocks, newBlocks) {
    var changes, newBlockMap, prev, removes;
    newBlockMap = {};
    removes = {};
    changes = {
      removes: removes,
      sets: newBlockMap,
      first: this.getFirst(),
      oldBlocks: oldBlocks,
      newBlocks: newBlocks
    };
    prev = this.computeRemovesAndNewBlockIds(oldBlocks, newBlocks, newBlockMap, removes);
    this.patchNewBlocks(oldBlocks, newBlocks, changes, newBlockMap, removes, prev);
    this.removeDuplicateChanges(newBlockMap);
    return this.change(changes);
  };

  BasicEditingOptions.prototype.computeRemovesAndNewBlockIds = function(oldBlocks, newBlocks, newBlockMap, removes) {
    var i, j, l, len, len1, newBlock, oldBlock, prev, ref;
    ref = oldBlocks.slice(newBlocks.length, oldBlocks.length);
    for (j = 0, len = ref.length; j < len; j++) {
      oldBlock = ref[j];
      removes[oldBlock._id] = oldBlock;
    }
    prev = null;
    for (i = l = 0, len1 = newBlocks.length; l < len1; i = ++l) {
      newBlock = newBlocks[i];
      if (oldBlock = oldBlocks[i]) {
        newBlock._id = oldBlock._id;
        newBlock.prev = oldBlock.prev;
        newBlock.next = oldBlock.next;
      } else {
        newBlock._id = this.newId();
        if (prev) {
          link(prev, newBlock);
        }
      }
      prev = newBlockMap[newBlock._id] = newBlock;
    }
    return prev;
  };

  BasicEditingOptions.prototype.patchNewBlocks = function(oldBlocks, newBlocks, changes, newBlockMap, removes, prev) {
    var lastBlock, next;
    if (oldBlocks.length !== newBlocks.length) {
      if (!prev && (prev = this.copyBlock(this.getBlock(oldBlocks[0].prev)))) {
        newBlockMap[prev._id] = prev;
      }
      lastBlock = last(oldBlocks);
      if (next = this.copyBlock(this.getBlock((lastBlock ? lastBlock.next : this.getFirst())))) {
        newBlockMap[next._id] = next;
        if (!(next.prev = prev != null ? prev._id : void 0)) {
          changes.first = next._id;
        }
      }
      if (prev) {
        if (!oldBlocks.length || !this.getFirst() || removes[this.getFirst()]) {
          changes.first = newBlocks[0]._id;
        }
        return prev.next = next != null ? next._id : void 0;
      }
    }
  };

  BasicEditingOptions.prototype.removeDuplicateChanges = function(newBlockMap) {
    var block, dups, id, oldBlock, results;
    dups = [];
    for (id in newBlockMap) {
      block = newBlockMap[id];
      if ((oldBlock = this.getBlock(id)) && block.text === oldBlock.text && block.next === oldBlock.next && block.prev === oldBlock.prev) {
        dups.push(id);
      }
    }
    results = [];
    for (id in dups) {
      results.push(delete newBlockMap[id]);
    }
    return results;
  };

  BasicEditingOptions.prototype.change = function(arg) {
    var block, first, id, j, len, removes, results, sets;
    first = arg.first, removes = arg.removes, sets = arg.sets;
    this.first = first;
    for (j = 0, len = removes.length; j < len; j++) {
      id = removes[j];
      delete this.blocks[id];
    }
    results = [];
    for (id in sets) {
      block = sets[id];
      results.push(this.blocks[id] = block);
    }
    return results;
  };

  BasicEditingOptions.prototype.getBlock = function(id) {
    return this.blocks[id];
  };

  BasicEditingOptions.prototype.bindings = defaultBindings;

  BasicEditingOptions.prototype.blockColumn = function(pos) {
    return pos.textPosition().left;
  };

  BasicEditingOptions.prototype.topRect = function() {
    return null;
  };

  BasicEditingOptions.prototype.keyUp = function() {};

  BasicEditingOptions.prototype.domCursor = function(node, pos) {
    return new DOMCursor(node, pos).addFilter(function(n) {
      return (n.hasAttribute('data-noncontent') && 'skip') || isEditable(n.node);
    });
  };

  BasicEditingOptions.prototype.getContainer = function(node) {
    if (this.editor.node[0].compareDocumentPosition(node) & Element.DOCUMENT_POSITION_CONTAINED_BY) {
      return $(node).closest('[data-block]')[0];
    }
  };

  BasicEditingOptions.prototype.load = function(text) {
    this.replaceBlocks(this.blockList(), this.parseBlocks(text));
    this.editor.node.html(this.renderBlocks());
    return this.trigger('load');
  };

  BasicEditingOptions.prototype.blockCount = function() {
    var b, c;
    c = 0;
    for (b in this.blocks) {
      c++;
    }
    return c;
  };

  BasicEditingOptions.prototype.blockList = function() {
    var bl, next, results;
    next = this.getFirst();
    results = [];
    while (next) {
      bl = this.getBlock(next);
      next = bl.next;
      results.push(bl);
    }
    return results;
  };

  BasicEditingOptions.prototype.renderBlocks = function() {
    var html, next, ref, result;
    result = '';
    next = this.getFirst();
    while (next && (ref = this.renderBlock(this.getBlock(next)), html = ref[0], next = ref[1], ref)) {
      result += html;
    }
    return result;
  };

  return BasicEditingOptions;

})(Observable);

DataStore = (function(superClass) {
  extend(DataStore, superClass);

  function DataStore() {
    DataStore.__super__.constructor.call(this);
    this.blocks = {};
  }

  DataStore.prototype.getBlock = function(id) {
    return this.blocks[id];
  };

  DataStore.prototype.check = function() {
    var bl, k, next, oldBl, prev, seen;
    seen = {};
    next = this.first;
    prev = null;
    while (next) {
      prev = next;
      if (seen[next]) {
        throw new Error("cycle in next links");
      }
      seen[next] = true;
      oldBl = bl;
      bl = this.blocks[next];
      if (!bl) {
        throw new Error("Next of " + oldBl.id + " doesn't exist");
      }
      next = bl.next;
    }
    for (k in this.blocks) {
      if (!seen[k]) {
        throw new Error(k + " not in next chain");
      }
    }
    seen = {};
    while (prev) {
      if (seen[prev]) {
        throw new Error("cycle in prev links");
      }
      seen[prev] = true;
      oldBl = bl;
      bl = this.blocks[prev];
      if (!bl) {
        throw new Error("Prev of " + oldBl.id + " doesn't exist");
      }
      prev = bl.prev;
    }
    for (k in this.blocks) {
      if (!seen[k]) {
        throw new Error(k + " not in prev chain");
      }
    }
    return null;
  };

  DataStore.prototype.blockList = function() {
    var bl, next, results;
    next = this.first;
    results = [];
    while (next) {
      bl = this.blocks[next];
      next = bl.next;
      results.push(bl);
    }
    return results;
  };

  DataStore.prototype.change = function(changes) {
    return this.triggerChange(this.makeChange(changes));
  };

  DataStore.prototype.makeChange = function(arg) {
    var bl, block, first, id, newBlocks, old, oldFirst, removed, removes, sets;
    first = arg.first, removes = arg.removes, sets = arg.sets;
    old = {};
    newBlocks = {};
    removed = [];
    oldFirst = first;
    this.first = first;
    for (id in removes) {
      if (bl = this.blocks[id]) {
        removed.push(bl);
        delete this.blocks[id];
      }
    }
    for (id in sets) {
      block = sets[id];
      if (this.blocks[id]) {
        old[id] = block;
      } else {
        newBlocks[id] = block;
      }
      this.blocks[id] = block;
    }
    this.check();
    return {
      adds: newBlocks,
      updates: old,
      removes: removed,
      oldFirst: first
    };
  };

  DataStore.prototype.triggerChange = function(changes) {
    return this.trigger('change', changes);
  };

  return DataStore;

})(Observable);

DataStoreEditingOptions = (function(superClass) {
  extend(DataStoreEditingOptions, superClass);

  function DataStoreEditingOptions(data) {
    this.data = data;
    DataStoreEditingOptions.__super__.constructor.call(this);
    this.data.on('change', (function(_this) {
      return function(change) {
        return _this.changed(change);
      };
    })(this));
  }

  DataStoreEditingOptions.prototype.edit = function(oldBlocks, newBlocks) {
    return this.replaceBlocks(oldBlocks, newBlocks);
  };

  DataStoreEditingOptions.prototype.getBlock = function(id) {
    return this.data.getBlock(id);
  };

  DataStoreEditingOptions.prototype.getFirst = function(first) {
    return this.data.first;
  };

  DataStoreEditingOptions.prototype.change = function(changes) {
    return this.data.change(changes);
  };

  DataStoreEditingOptions.prototype.changed = function(change) {
    return this.editor.node.html(this.renderBlocks());
  };

  return DataStoreEditingOptions;

})(BasicEditingOptions);

isEditable = function(n) {
  n = n.nodeType === n.TEXT_NODE ? n.parentNode : n;
  return n.isContentEditable;
};

link = function(prev, next) {
  prev.next = next._id;
  return next.prev = prev._id;
};

blockText = function(blocks) {
  var block;
  return ((function() {
    var j, len, results;
    results = [];
    for (j = 0, len = blocks.length; j < len; j++) {
      block = blocks[j];
      results.push(block.text);
    }
    return results;
  })()).join('');
};

_to_ascii = {
  '188': '44',
  '109': '45',
  '190': '46',
  '191': '47',
  '192': '96',
  '220': '92',
  '222': '39',
  '221': '93',
  '219': '91',
  '173': '45',
  '187': '61',
  '186': '59',
  '189': '45'
};

shiftUps = {
  "96": "~",
  "49": "!",
  "50": "@",
  "51": "#",
  "52": "$",
  "53": "%",
  "54": "^",
  "55": "&",
  "56": "*",
  "57": "(",
  "48": ")",
  "45": "_",
  "61": "+",
  "91": "{",
  "93": "}",
  "92": "|",
  "59": ":",
  "39": "\"",
  "44": "<",
  "46": ">",
  "47": "?"
};

getEventChar = function(e) {
  var c;
  c = e.charCode || e.keyCode || e.which;
  if (_to_ascii.hasOwnProperty(c)) {
    c = _to_ascii[c];
  }
  if (!e.shiftKey && (c >= 65 && c <= 90)) {
    c = String.fromCharCode(c + 32);
  } else if (e.shiftKey && shiftUps.hasOwnProperty(c)) {
    c = shiftUps[c];
  } else {
    c = String.fromCharCode(c);
  }
  return c;
};

shiftKey = function(c) {
  return (15 < c && c < 19);
};

modifiers = function(e, c) {
  var res;
  res = specialKeys[c] || String.fromCharCode(c);
  if (e.altKey) {
    res = "M-" + res;
  }
  if (e.ctrlKey) {
    res = "C-" + res;
  }
  if (e.shiftKey) {
    res = "S-" + res;
  }
  return res;
};

modifyingKey = function(c, e) {
  return !e.altKey && !e.ctrlKey && (((47 < c && c < 58)) || c === 32 || c === ENTER || c === BS || c === DEL || ((64 < c && c < 91)) || ((95 < c && c < 112)) || ((185 < c && c < 193)) || ((218 < c && c < 223)));
};

last = function(array) {
  return array.length && array[array.length - 1];
};

root = LeisureEditCore;

root.Observable = Observable;

root.BasicEditingOptions = BasicEditingOptions;

root.DataStore = DataStore;

root.DataStoreEditingOptions = DataStoreEditingOptions;

root.defaultBindings = defaultBindings;

root.last = last;

root.link = link;

root.blockText = blockText;

if (typeof window !== "undefined" && window !== null) {
  window.LeisureEditCore = root;
} else {
  module.exports = root;
}

//# sourceMappingURL=editor.js.map

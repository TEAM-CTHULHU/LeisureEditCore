// Generated by CoffeeScript 1.7.1

/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
 */
var ATTR_NAME, AttrHtml, DRAWER_NAME, Drawer, END_NAME, Fragment, HL_LEVEL, HL_PRIORITY, HL_TAGS, HL_TODO, HTML, HTML_INFO, HTML_START_NAME, Headline, KW_BOILERPLATE, KW_INFO, KW_NAME, Keyword, LINK_DESCRIPTION, LINK_HEAD, LINK_INFO, LIST_BOILERPLATE, LIST_CHECK, LIST_CHECK_VALUE, LIST_INFO, LIST_LEVEL, Link, ListItem, Meat, MeatParser, Node, PROPERTY_KEY, PROPERTY_VALUE, RES_NAME, Results, SRC_BOILERPLATE, SRC_INFO, SRC_NAME, SimpleMarkup, Source, attrHtmlLineRE, attrHtmlRE, buildHeadlineRE, checkMatch, drawerRE, endRE, fullLine, headlineRE, htmlEndRE, htmlStartRE, imagePathRE, inListItem, keywordPropertyRE, keywordRE, leisurePathRE, lineBreakPat, linkRE, listContentOffset, listRE, markupText, markupTypes, matchLine, meatStart, nextOrgNode, parseAttr, parseDrawer, parseHeadline, parseHtmlBlock, parseKeyword, parseList, parseMeat, parseOrgChunk, parseOrgMode, parseRestOfMeat, parseResults, parseSrcBlock, parseTags, propertyRE, resultsLineRE, resultsRE, root, simpleRE, srcEndRE, srcStartRE, tagsRE, todoKeywords, todoRE, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

(typeof window !== "undefined" && window !== null ? window : global).Org = root = (_ref = typeof require === "function" ? require('./preamble') : void 0) != null ? _ref : (typeof Org !== "undefined" && Org !== null ? Org : {});

_ = typeof Lazy !== "undefined" && Lazy !== null ? Lazy : typeof require === "function" ? require('./lazy') : void 0;

todoKeywords = ['TODO', 'DONE'];

buildHeadlineRE = function() {
  return new RegExp('^(\\*+) *(' + todoKeywords.join('|') + ')?(?: *(?:\\[#(A|B|C)\\]))?[^\\n]*?((?:[\\w@%#]*:[\\w@%#:]*)? *)$', 'm');
};

HL_LEVEL = 1;

HL_TODO = 2;

HL_PRIORITY = 3;

HL_TAGS = 4;

headlineRE = buildHeadlineRE();

todoRE = /^(\*+) *(TODO|DONE)/;

tagsRE = /:[^:]*/;

KW_BOILERPLATE = 1;

KW_NAME = 2;

KW_INFO = 3;

keywordRE = /^(#\+([^:\n]+): *)([^\n]*)$/im;

SRC_BOILERPLATE = 1;

SRC_NAME = 2;

SRC_INFO = 3;

srcStartRE = /^(#\+(BEGIN_SRC) *)([^\n]*)$/im;

END_NAME = 1;

srcEndRE = /^#\+(END_SRC)( *)$/im;

RES_NAME = 1;

resultsRE = /^#\+(RESULTS): *$/im;

resultsLineRE = /^([:|] .*)(?:\n|$)/i;

DRAWER_NAME = 1;

drawerRE = /^:([^\n:]*): *$/im;

endRE = /^:END: *$/im;

PROPERTY_KEY = 1;

PROPERTY_VALUE = 2;

propertyRE = /^:([^\n:]+): *([^\n]*)$/img;

LIST_LEVEL = 1;

LIST_BOILERPLATE = 2;

LIST_CHECK = 3;

LIST_CHECK_VALUE = 4;

LIST_INFO = 5;

listRE = /^( *)(- *)(\[( |X)\] +)?(.*)$/m;

simpleRE = /\B(\*[/+=~\w](.*?[/+=~\w])?\*|\/[*+=~\w](.*?[*+=~\w])?\/|\+[*/=~\w](.*?[*/=~\w])?\+|=[+*/~\w](.*?[+*/~\w])?=|~[=+*/\w](.*?[=+*/\w])?~)(\B|$)|\b_[^_]*\B_(\b|$)/;

LINK_HEAD = 1;

LINK_INFO = 2;

LINK_DESCRIPTION = 3;

linkRE = /(\[\[([^\]]*)\])(?:\[([^\]]*)\])?\]/;

htmlStartRE = /^#\+(BEGIN_HTML\b)(.*)$/im;

HTML_START_NAME = 1;

HTML_INFO = 2;

htmlEndRE = /^#\+END_HTML *$/im;

ATTR_NAME = 1;

attrHtmlRE = /^#\+(ATTR_HTML): *$/im;

attrHtmlLineRE = /^([:|] .*)(?:\n|$)/i;

imagePathRE = /\.(png|jpg|jpeg|gif|svg|tiff|bmp)$/i;

leisurePathRE = /^leisure:([^/]*)\/?(.*)$/;

keywordPropertyRE = /:([^ ]+)/;

matchLine = function(txt) {
  var _ref1;
  if (((_ref1 = txt.match(simpleRE)) != null ? _ref1.index : void 0) === 0) {
    return false;
  } else {
    return checkMatch(txt, srcStartRE, 'srcStart') || checkMatch(txt, srcEndRE, 'srcEnd') || checkMatch(txt, resultsRE, 'results') || checkMatch(txt, attrHtmlRE, 'attr') || checkMatch(txt, keywordRE, 'keyword') || checkMatch(txt, headlineRE, function(m) {
      return "headline-" + m[HL_LEVEL].length;
    }) || checkMatch(txt, listRE, 'list') || checkMatch(txt, htmlStartRE, 'htmlStart') || checkMatch(txt, htmlEndRE, 'htmlEnd');
  }
};

checkMatch = function(txt, pat, result) {
  var m;
  m = txt.match(pat);
  if ((m != null ? m.index : void 0) === 0) {
    if (typeof result === 'string') {
      return result;
    } else {
      return result(m);
    }
  } else {
    return false;
  }
};

Node = (function() {
  function Node() {
    this.markup = markupText(this.text);
  }

  Node.prototype.count = function() {
    return 1;
  };

  Node.prototype.length = function() {
    return this.text.length;
  };

  Node.prototype.end = function() {
    return this.offset + this.text.length;
  };

  Node.prototype.toJson = function() {
    return JSON.stringify(this.toJsonObject(), null, "  ");
  };

  Node.prototype.toJsonObject = function() {
    var obj;
    obj = this.jsonDef();
    obj.nodeId = this.nodeId;
    return obj;
  };

  Node.prototype.allText = function() {
    return this.text;
  };

  Node.prototype.block = false;

  Node.prototype.findNodeAt = function(pos) {
    if (this.offset <= pos && pos < this.offset + this.text.length) {
      return this;
    } else {
      return null;
    }
  };

  Node.prototype.scan = function(func) {
    return func(this);
  };

  Node.prototype.scanWithChildren = function(func) {
    var c, _i, _len, _ref1, _results;
    func(this);
    _ref1 = this.children;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      _results.push(c.scan(func));
    }
    return _results;
  };

  Node.prototype.linkNodes = function() {
    return this;
  };

  Node.prototype.linkChild = function(child) {
    child.linkNodes();
    return child.linkTo(this);
  };

  Node.prototype.linkChildren = function() {
    var c, prev, _i, _len, _ref1;
    prev = null;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      if (prev) {
        prev.next = c;
      }
      prev = c;
      this.linkChild(c);
    }
    return this;
  };

  Node.prototype.contains = function(node) {
    var _ref1;
    while (node) {
      if (node === this) {
        return true;
      }
      node = (_ref1 = node.fragment) != null ? _ref1 : node.parent;
    }
    return false;
  };

  Node.prototype.next = null;

  Node.prototype.prev = null;

  Node.prototype.top = function() {
    if (!this.parent) {
      return this;
    } else {
      return this.parent.top();
    }
  };

  Node.prototype.toString = function() {
    return this.toJson();
  };

  Node.prototype.allTags = function() {
    var _ref1, _ref2;
    return (_ref1 = (_ref2 = this.parent) != null ? _ref2.allTags() : void 0) != null ? _ref1 : [];
  };

  Node.prototype.allProperties = function() {
    var _ref1, _ref2;
    return (_ref1 = (_ref2 = this.parent) != null ? _ref2.allProperties() : void 0) != null ? _ref1 : {};
  };

  Node.prototype.linkTo = function(parent) {
    this.parent = parent;
  };

  Node.prototype.fixOffsets = function(newOff) {
    this.offset = newOff;
    if (this.children) {
      return this.fixChildrenOffsets();
    } else {
      return newOff + this.allText().length;
    }
  };

  Node.prototype.fixChildrenOffsets = function() {
    var child, offset, _i, _len, _ref1;
    offset = this.offset + this.text.length;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      offset = child.fixOffsets(offset);
    }
    return offset;
  };

  Node.prototype.inNewMeat = function() {
    return false;
  };

  Node.prototype.getRightmostDescendent = function() {
    var child, _ref1;
    child = this;
    while ((_ref1 = child.children) != null ? _ref1.length : void 0) {
      child = child.children[child.children.length - 1];
    }
    return child;
  };

  Node.prototype.getLeftmostDescendent = function() {
    var child, _ref1;
    child = this;
    while ((_ref1 = child.children) != null ? _ref1.length : void 0) {
      child = child.children[0];
    }
    return child;
  };

  Node.prototype.getPrecedingNode = function() {
    var parent, _ref1;
    if (this.prev) {
      return this.prev.getRightmostDescendent();
    } else if (parent = (_ref1 = this.fragment) != null ? _ref1 : this.parent) {
      if (parent.children[0] === this) {
        return parent;
      }
      return parent.children[parent.children.indexOf(this) - 1].getRightmostDescendent();
    }
  };

  Node.prototype.getFollowingNode = function() {
    var parent, _ref1;
    if (this.next) {
      return this.next.getLeftmostDescendent();
    } else if (parent = (_ref1 = this.fragment) != null ? _ref1 : this.parent) {
      if (parent.children[parent.children.length - 1] === this) {
        return parent;
      }
      return parent.children[parent.children.indexOf(this) + 1].getLeftmostDescendent();
    }
  };

  return Node;

})();

Headline = (function(_super) {
  __extends(Headline, _super);

  function Headline(text, level, todo, priority, tags, children, offset) {
    this.text = text;
    this.level = level;
    this.todo = todo;
    this.priority = priority;
    this.tags = tags;
    this.children = children;
    this.offset = offset;
    Headline.__super__.constructor.call(this);
    this.properties = {};
  }

  Headline.prototype.count = function() {
    var count, node, _i, _len, _ref1;
    count = 1;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      count += node.count();
    }
    return count;
  };

  Headline.prototype.block = true;

  Headline.prototype.lowerThan = function(l) {
    return l < this.level;
  };

  Headline.prototype.length = function() {
    return this.end() - this.offset;
  };

  Headline.prototype.end = function() {
    var lastChild;
    if (this.children.length) {
      lastChild = this.children[this.children.length - 1];
      return lastChild.offset + lastChild.length();
    } else {
      return Headline.__super__.end.call(this);
    }
  };

  Headline.prototype.type = 'headline';

  Headline.prototype.jsonDef = function() {
    var c;
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      level: this.level,
      todo: this.todo,
      priority: this.priority,
      tags: this.tags,
      children: (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.children;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push(c.toJsonObject());
        }
        return _results;
      }).call(this),
      properties: this.properties
    };
  };

  Headline.prototype.allText = function() {
    var c;
    return this.text + ((function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(c.allText());
      }
      return _results;
    }).call(this)).join('');
  };

  Headline.prototype.findNodeAt = function(pos) {
    var child, res, _i, _len, _ref1;
    if (pos < this.offset || this.offset + this.length() < pos) {
      return null;
    } else if (pos < this.offset + this.text.length) {
      return this;
    } else {
      _ref1 = this.children;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        if (res = child.findNodeAt(pos)) {
          return res;
        }
      }
      return null;
    }
  };

  Headline.prototype.scan = Node.prototype.scanWithChildren;

  Headline.prototype.linkNodes = function() {
    return this.linkChildren();
  };

  Headline.prototype.addTags = function(set) {
    var tag, _i, _len, _ref1;
    _ref1 = parseTags(this.tags);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      tag = _ref1[_i];
      set[tag] = true;
    }
    return set;
  };

  Headline.prototype.addProperties = function(props) {
    var k, v, _ref1;
    _ref1 = this.properties;
    for (k in _ref1) {
      v = _ref1[k];
      props[k] = v;
    }
    return props;
  };

  Headline.prototype.addAllTags = function() {
    var _ref1;
    return this.addTags(((_ref1 = this.parent) != null ? _ref1.addAllTags() : void 0) || {});
  };

  Headline.prototype.allProperties = function() {
    var _ref1;
    return this.addProperties(((_ref1 = this.parent) != null ? _ref1.allProperties() : void 0) || {});
  };

  Headline.prototype.allTags = function() {
    var k, _results;
    _results = [];
    for (k in this.addAllTags()) {
      _results.push(k);
    }
    return _results;
  };

  return Headline;

})(Node);

Fragment = (function(_super) {
  __extends(Fragment, _super);

  function Fragment(offset, children) {
    this.offset = offset;
    this.children = children;
    this.text = '';
  }

  Fragment.prototype.count = function() {
    var count, node, _i, _len, _ref1;
    count = 1;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      count += node.count();
    }
    return count;
  };

  Fragment.prototype.end = function() {
    var lastChild;
    if (this.children.length) {
      lastChild = this.children[this.children.length - 1];
      return lastChild.offset + lastChild.length();
    } else {
      return Fragment.__super__.end.call(this);
    }
  };

  Fragment.prototype.block = true;

  Fragment.prototype.length = function() {
    return this.end() - this.offset;
  };

  Fragment.prototype.type = 'fragment';

  Fragment.prototype.jsonDef = function() {
    var c;
    return {
      type: this.type,
      offset: this.offset,
      children: (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.children;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push(c.toJsonObject());
        }
        return _results;
      }).call(this)
    };
  };

  Fragment.prototype.allText = function() {
    var c;
    return this.text + ((function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(c.allText());
      }
      return _results;
    }).call(this)).join('');
  };

  Fragment.prototype.findNodeAt = function(pos) {
    var child, res, _i, _len, _ref1;
    if (pos < this.offset || this.offset + this.length() < pos) {
      return null;
    } else if (pos < this.offset + this.text.length) {
      return this;
    } else {
      _ref1 = this.children;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        if (res = child.findNodeAt(pos)) {
          return res;
        }
      }
      return null;
    }
  };

  Fragment.prototype.linkNodes = function() {
    return this.linkChildren();
  };

  Fragment.prototype.linkChild = function(child) {
    child.fragment = this;
    return Fragment.__super__.linkChild.call(this, child);
  };

  Fragment.prototype.linkTo = function(parent) {
    var c, _i, _len, _ref1, _results;
    if (this.children.length) {
      this.children[0].prev = this.prev;
      this.children[this.children.length - 1].next = this.next;
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(c.linkTo(parent));
      }
      return _results;
    }
  };

  return Fragment;

})(Node);

Meat = (function(_super) {
  __extends(Meat, _super);

  function Meat(text, offset) {
    this.text = text;
    this.offset = offset;
    Meat.__super__.constructor.call(this);
  }

  Meat.prototype.lowerThan = function(l) {
    return true;
  };

  Meat.prototype.type = 'meat';

  Meat.prototype.jsonDef = function() {
    return {
      type: this.type,
      text: this.text,
      offset: this.offset
    };
  };

  Meat.prototype.inNewMeat = function() {
    var cur, m, meat, t, _i, _len;
    meat = [];
    cur = this;
    while (cur && !(cur instanceof Headline || inListItem(cur))) {
      meat.push(cur);
      cur = cur.getPrecedingNode();
    }
    meat.reverse();
    t = '';
    for (_i = 0, _len = meat.length; _i < _len; _i++) {
      m = meat[_i];
      t += m.allText();
    }
    return t.match(meatStart);
  };

  return Meat;

})(Node);

inListItem = function(org) {
  var _ref1;
  return org && (org instanceof ListItem || inListItem((_ref1 = org.fragment) != null ? _ref1 : org.parent));
};

meatStart = /^\S|\n\n\S/;

markupTypes = {
  "*": 'bold',
  "/": 'italic',
  "_": 'underline',
  "=": 'verbatim',
  "~": 'code',
  "+": 'strikethrough'
};

SimpleMarkup = (function(_super) {
  __extends(SimpleMarkup, _super);

  function SimpleMarkup(text, offset, children) {
    this.text = text;
    this.offset = offset;
    this.children = children;
    this.markupType = markupTypes[this.text[0]];
  }

  SimpleMarkup.prototype.count = function() {
    var count, node, _i, _len, _ref1;
    count = 1;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      count += node.count();
    }
    return count;
  };

  SimpleMarkup.prototype.type = 'simple';

  SimpleMarkup.prototype.linkNodes = function() {
    return this.linkChildren();
  };

  SimpleMarkup.prototype.jsonDef = function() {
    var c;
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      markupType: this.markupType,
      children: (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.children;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push(c.toJsonObject());
        }
        return _results;
      }).call(this)
    };
  };

  SimpleMarkup.prototype.scan = Node.prototype.scanWithChildren;

  return SimpleMarkup;

})(Meat);

Link = (function(_super) {
  __extends(Link, _super);

  function Link(text, offset, path, children) {
    this.text = text;
    this.offset = offset;
    this.path = path;
    this.children = children;
  }

  Link.prototype.count = function() {
    var count, node, _i, _len, _ref1;
    count = 1;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      count += node.count();
    }
    return count;
  };

  Link.prototype.type = 'link';

  Link.prototype.jsonDef = function() {
    var c;
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      path: this.path,
      children: (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.children;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push(c.toJsonObject());
        }
        return _results;
      }).call(this)
    };
  };

  Link.prototype.scan = Node.prototype.scanWithChildren;

  Link.prototype.isImage = function() {
    return this.path.match(imagePathRE);
  };

  Link.prototype.isLeisure = function() {
    return this.path.match(leisurePathRE);
  };

  Link.prototype.descriptionText = function() {
    var child;
    return ((function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        _results.push(child.allText());
      }
      return _results;
    }).call(this)).join(' ');
  };

  return Link;

})(Meat);

ListItem = (function(_super) {
  __extends(ListItem, _super);

  function ListItem(text, offset, level, checked, contentOffset, children) {
    this.text = text;
    this.offset = offset;
    this.level = level;
    this.checked = checked;
    this.contentOffset = contentOffset;
    this.children = children;
    ListItem.__super__.constructor.call(this, this.text, this.offset);
  }

  ListItem.prototype.count = function() {
    var count, node, _i, _len, _ref1;
    count = 1;
    _ref1 = this.children;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      count += node.count();
    }
    return count;
  };

  ListItem.prototype.type = 'list';

  ListItem.prototype.linkNodes = function() {
    return this.linkChildren();
  };

  ListItem.prototype.jsonDef = function() {
    var child, obj;
    obj = {
      type: this.type,
      text: this.text,
      level: this.level,
      offset: this.offset,
      contentOffset: this.contentOffset,
      children: (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.children;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          _results.push(child.toJsonObject());
        }
        return _results;
      }).call(this)
    };
    if (this.checked != null) {
      obj.checked = this.checked;
    }
    return obj;
  };

  ListItem.prototype.getParent = function() {
    var li;
    if (this.level === 0) {
      null;
    }
    li = this;
    while (li = li.getPreviousListItem()) {
      if (li.level < this.level) {
        return li;
      }
    }
  };

  ListItem.prototype.getPreviousListItem = function() {
    var cur, parent, _ref1;
    parent = this.fragment || this.parent;
    cur = this;
    while (cur = cur.getPrecedingNode()) {
      if (!(parent.contains(cur)) || cur.inNewMeat()) {
        return null;
      }
      if (((_ref1 = cur.fragment) != null ? _ref1 : cur.parent) === parent && cur instanceof ListItem) {
        return cur;
      }
    }
    return null;
  };

  ListItem.prototype.getNextListItem = function() {
    var cur, parent, _ref1;
    parent = this.fragment || this.parent;
    cur = this;
    while (cur = cur.getFollowingNode()) {
      if (!(parent.contains(cur)) || cur.inNewMeat()) {
        return null;
      }
      if (((_ref1 = cur.fragment) != null ? _ref1 : cur.parent) === parent && cur instanceof ListItem) {
        return cur;
      }
    }
    return null;
  };

  ListItem.prototype.scan = Node.prototype.scanWithChildren;

  ListItem.prototype.inNewMeat = function() {
    return true;
  };

  return ListItem;

})(Meat);

Drawer = (function(_super) {
  __extends(Drawer, _super);

  function Drawer(text, offset, name, contentPos, endPos) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.contentPos = contentPos;
    this.endPos = endPos;
    Drawer.__super__.constructor.call(this, this.text, this.offset);
  }

  Drawer.prototype.type = 'drawer';

  Drawer.prototype.jsonDef = function() {
    return {
      type: this.type,
      name: this.name,
      text: this.text,
      offset: this.offset,
      contentPos: this.contentPos,
      endPos: this.endPos
    };
  };

  Drawer.prototype.leading = function() {
    return this.text.substring(0, this.contentPos);
  };

  Drawer.prototype.content = function() {
    return this.text.substring(this.contentPos, this.endPos);
  };

  Drawer.prototype.trailing = function() {
    return this.text.substring(this.endPos);
  };

  Drawer.prototype.linkTo = function(node) {
    var m, t, _ref1, _results;
    Drawer.__super__.linkTo.call(this, node);
    if (this.name.toLowerCase() === 'properties') {
      if (!(node instanceof Headline)) {
        return console.log("WARNING: Drawer's parent is not a Headline'");
      } else {
        t = this.text.substring(this.contentPos, this.endPos);
        _results = [];
        while (m = propertyRE.exec(t)) {
          _results.push(node.properties[m[PROPERTY_KEY]] = ((_ref1 = m[PROPERTY_VALUE]) != null ? _ref1 : '').trim());
        }
        return _results;
      }
    }
  };

  return Drawer;

})(Meat);

Keyword = (function(_super) {
  __extends(Keyword, _super);

  function Keyword(text, offset, name, info) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.info = info;
    Keyword.__super__.constructor.call(this, this.text, this.offset);
  }

  Keyword.prototype.block = true;

  Keyword.prototype.type = 'keyword';

  Keyword.prototype.jsonDef = function() {
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      name: this.name,
      info: this.info
    };
  };

  Keyword.prototype.attributes = function() {
    var o;
    o = _(this.info.split(keywordPropertyRE)).drop(1).map(function(str) {
      return str.trim();
    }).chunk(2);
    if (o.isEmpty()) {
      return null;
    } else {
      return o.toObject();
    }
  };

  Keyword.prototype.lead = function() {
    return _(this.info.split(keywordPropertyRE)).first();
  };

  return Keyword;

})(Meat);

Source = (function(_super) {
  __extends(Source, _super);

  function Source(text, offset, name, info, infoPos, content, contentPos) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.info = info;
    this.infoPos = infoPos;
    this.content = content;
    this.contentPos = contentPos;
    Source.__super__.constructor.call(this, this.text, this.offset, this.name, this.info);
  }

  Source.prototype.type = 'source';

  Source.prototype.getLanguage = function() {
    var _ref1;
    return (_ref1 = this.lead()) != null ? _ref1.trim().toLowerCase() : void 0;
  };

  Source.prototype.jsonDef = function() {
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      name: this.name,
      info: this.info,
      infoPos: this.infoPos,
      content: this.content,
      contentPos: this.contentPos,
      contentLength: this.content.length
    };
  };

  return Source;

})(Keyword);

HTML = (function(_super) {
  __extends(HTML, _super);

  function HTML(text, offset, name, contentPos, contentLength, info) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.contentPos = contentPos;
    this.contentLength = contentLength;
    this.info = info;
    HTML.__super__.constructor.call(this, this.text, this.offset, this.name, this.info);
  }

  HTML.prototype.type = 'html';

  HTML.prototype.leading = function() {
    return this.text.substring(0, this.contentPos);
  };

  HTML.prototype.trailing = function() {
    return this.text.substring(this.contentPos + this.contentLength);
  };

  HTML.prototype.content = function() {
    return this.text.substring(this.contentPos, this.contentPos + this.contentLength);
  };

  HTML.prototype.jsonDef = function() {
    return {
      type: this.type,
      info: this.info || '',
      text: this.text,
      offset: this.offset,
      contentPos: this.contentPos,
      contentLength: this.contentLength
    };
  };

  return HTML;

})(Keyword);

Results = (function(_super) {
  __extends(Results, _super);

  function Results(text, offset, name, contentPos) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.contentPos = contentPos;
    Results.__super__.constructor.call(this, this.text, this.offset, this.name);
  }

  Results.prototype.type = 'results';

  Results.prototype.content = function() {
    return this.text.substring(this.contentPos);
  };

  Results.prototype.jsonDef = function() {
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      name: this.name,
      contentPos: this.contentPos
    };
  };

  return Results;

})(Keyword);

AttrHtml = (function(_super) {
  __extends(AttrHtml, _super);

  function AttrHtml(text, offset, name, contentPos) {
    this.text = text;
    this.offset = offset;
    this.name = name;
    this.contentPos = contentPos;
    AttrHtml.__super__.constructor.call(this, this.text, this.offset, this.name);
  }

  AttrHtml.prototype.type = 'attr';

  AttrHtml.prototype.jsonDef = function() {
    return {
      type: this.type,
      text: this.text,
      offset: this.offset,
      name: this.name,
      contentPos: this.contentPos
    };
  };

  return AttrHtml;

})(Keyword);

nextOrgNode = function(node) {
  var up;
  up = false;
  while (node) {
    if (node.children && !up && node.children.length) {
      return node.children[0];
    } else if (node.next) {
      return node.next;
    } else {
      up = true;
      node = node.parent;
    }
  }
  return null;
};

parseOrgMode = function(text, offset, useFragment) {
  var res, rest, _ref1;
  if (text instanceof Node) {
    return text;
  } else {
    _ref1 = parseHeadline('', offset != null ? offset : 0, 0, void 0, void 0, void 0, text, text.length), res = _ref1[0], rest = _ref1[1];
    if (rest.length) {
      throw new Error("Text left after parsing: " + rest);
    }
    if (useFragment) {
      if (res.children.length === 1) {
        res = res.children[0];
      } else if (res.children.length > 1) {
        res = new Fragment(res.offset, res.children);
      }
    }
    return res.linkNodes();
  }
};

parseHeadline = function(text, offset, level, todo, priority, tags, rest, totalLen) {
  var child, children, oldRest, originalRest, _ref1;
  children = [];
  originalRest = rest;
  while (true) {
    oldRest = rest;
    _ref1 = parseOrgChunk(rest, originalRest.length - rest.length + offset, level), child = _ref1[0], rest = _ref1[1];
    if (!child) {
      break;
    }
    if (child.lowerThan(level)) {
      while (child) {
        children.push(child);
        child = child.next;
      }
    } else {
      rest = oldRest;
    }
  }
  return [new Headline(text, level, todo, priority, tags || '', children, offset), rest];
};

parseTags = function(text) {
  var t, tagArray, _i, _len, _ref1;
  tagArray = [];
  _ref1 = (text ? text.split(':') : []);
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    t = _ref1[_i];
    if (t) {
      tagArray.push(t);
    }
  }
  return tagArray;
};

fullLine = function(match, text) {
  return text.substring(match.index, match.index + match[0].length + (text[match.index + match[0].length] === '\n' ? 1 : 0));
};

parseOrgChunk = function(text, offset, level) {
  var l, line, m, meat, meatLen, simple, _ref1;
  if (!text) {
    return [null, text];
  } else {
    m = text.match(headlineRE);
    simple = ((_ref1 = text.match(simpleRE)) != null ? _ref1.index : void 0) === 0;
    if ((m != null ? m.index : void 0) === 0 && !simple) {
      if (m[HL_LEVEL].length <= level) {
        return [null, text];
      } else {
        line = fullLine(m, text);
        return parseHeadline(line, offset, m[HL_LEVEL].length, m[HL_TODO], m[HL_PRIORITY], m[HL_TAGS], text.substring(line.length), offset + text.length);
      }
    } else {
      if ((m != null ? m.index : void 0) === 0 && simple && (l = text.indexOf('\n')) > -1 && (m = text.substring(l).match(headlineRE))) {
        meatLen = m.index + l;
      } else {
        meatLen = m && (m.index > 0 || !simple) ? m.index : text.length;
      }
      meat = text.substring(0, meatLen);
      return parseMeat(meat, offset, text.substring(meatLen), false);
    }
  }
};

MeatParser = (function() {
  function MeatParser() {}

  MeatParser.prototype.checkPat = function(pattern, cont) {
    var line, match;
    if (!this.result && (match = this.meat.match(pattern))) {
      if (match.index === 0) {
        line = fullLine(match, this.meat);
        return this.result = cont(line, this.meat.substring(line.length) + this.rest, match);
      } else {
        return this.minLen = Math.min(this.minLen, match.index);
      }
    }
  };

  MeatParser.prototype.parse = function(meat, offset, rest, singleLine, level) {
    var m, meatText, newline;
    this.meat = meat;
    this.rest = rest;
    this.minLen = meat.length + offset;
    this.result = null;
    if (!this.singleLine) {
      this.checkPat(resultsRE, function(line, newRest) {
        return parseResults(line, offset, newRest);
      });
      this.checkPat(attrHtmlRE, function(line, newRest) {
        return parseAttr(line, offset, newRest);
      });
      this.checkPat(srcStartRE, function(line, newRest, srcStart) {
        return parseSrcBlock(line, offset, srcStart[SRC_INFO], srcStart[SRC_BOILERPLATE].length, newRest);
      });
      this.checkPat(htmlStartRE, function(line, newRest, html) {
        return parseHtmlBlock(line, offset, newRest, html);
      });
      this.checkPat(keywordRE, function(line, newRest, keyword) {
        return parseKeyword(keyword, line, offset, keyword[KW_NAME], keyword[KW_INFO], newRest);
      });
      this.checkPat(listRE, function(line, newRest, list) {
        var _ref1, _ref2;
        return parseList(list, line, offset, (_ref1 = (_ref2 = list[LIST_LEVEL]) != null ? _ref2.length : void 0) != null ? _ref1 : 0, list[LIST_CHECK_VALUE], list[LIST_INFO], newRest);
      });
      this.checkPat(drawerRE, function(line, newRest, drawer) {
        var end;
        if (end = newRest.match(endRE)) {
          return parseDrawer(line, drawer[DRAWER_NAME], offset, end, newRest);
        }
      });
    }
    if (this.result) {
      return this.result;
    } else {
      this.checkPat(simpleRE, function(line, newRest, simple) {
        var child, children, inside, insideOffset, _ref1;
        inside = simple[0].substring(1, simple[0].length - 1);
        insideOffset = offset + 1;
        children = [];
        while (inside) {
          _ref1 = parseMeat(inside, insideOffset, '', true), child = _ref1[0], inside = _ref1[1];
          while (child) {
            children.push(child);
            insideOffset = child.offset + child.text.length;
            child = child.next;
          }
        }
        return new SimpleMarkup(simple[0], offset, children);
      });
      this.checkPat(linkRE, function(line, newRest, link) {
        var child, children, inside, insideOffset, _ref1;
        inside = link[LINK_DESCRIPTION];
        insideOffset = offset + link[LINK_HEAD].length;
        children = [];
        while (inside) {
          _ref1 = parseMeat(inside, insideOffset, '', true), child = _ref1[0], inside = _ref1[1];
          while (child) {
            children.push(child);
            insideOffset = child.offset + child.text.length;
            child = child.next;
          }
        }
        return new Link(link[0], offset, link[LINK_INFO], children);
      });
      if (!this.result) {
        if (newline = meat.substring(0, 2) === '\n\n') {
          meatText = meat.substring(2);
        }
        meatText = meat.substring(0, this.minLen);
        if (m = meatText.match(lineBreakPat)) {
          meatText = meat.substring(0, m.index);
        }
        if (newline) {
          meatText = '\n\n' + meatText;
        }
        this.result = new Meat(meatText, offset);
      }
      return parseRestOfMeat(this.result, meat.substring(this.result.text.length), rest);
    }
  };

  return MeatParser;

})();

lineBreakPat = /\n\n/;

parseMeat = function(meat, offset, rest, singleLine) {
  return new MeatParser().parse(meat, offset, rest, singleLine);
};

parseRestOfMeat = function(node, meat, rest) {
  var node2, _ref1;
  if (meat && node.text[node.text.length - 1] !== '\n') {
    _ref1 = parseMeat(meat, node.offset + node.allText().length, rest, true), node2 = _ref1[0], rest = _ref1[1];
    node.next = node2;
    return [node, rest];
  } else {
    return [node, meat + rest];
  }
};

parseResults = function(text, offset, rest) {
  var lines, m, oldRest;
  oldRest = rest;
  while (m = rest.match(resultsLineRE)) {
    rest = rest.substring(m[0].length);
  }
  lines = oldRest.substring(0, oldRest.length - rest.length);
  return [new Results(text + lines, offset, text.match(resultsRE)[RES_NAME], text.length), rest];
};

parseAttr = function(text, offset, rest) {
  var lines, m, oldRest;
  oldRest = rest;
  while (m = rest.match(attrHrmlLineRE)) {
    rest = rest.substring(m[0].length);
  }
  lines = oldRest.substring(0, oldRest.length - rest.length);
  return [new AttrHtml(text + lines, offset, text.match(attrHtmlRE)[ATTR_NAME], text.length), rest];
};

parseDrawer = function(text, name, offset, end, rest) {
  var pos;
  pos = end.index + (fullLine(end, rest)).length;
  return [new Drawer(text + rest.substring(0, pos), offset, name, text.length, text.length + end.index), rest.substring(pos)];
};

parseKeyword = function(match, text, offset, name, info, rest) {
  return [new Keyword(text, offset, name, text.substring(match[KW_BOILERPLATE].length)), rest];
};

parseSrcBlock = function(text, offset, info, infoPos, rest) {
  var end, endLine, line, otherSrcStart;
  end = rest.match(srcEndRE);
  otherSrcStart = rest.match(srcStartRE);
  if (!end || (otherSrcStart && otherSrcStart.index < end.index)) {
    line = text.match(/^.*\n/);
    if (!line) {
      line = [text];
    }
    return [new Meat(line[0]), text.substring(line[0].length) + rest];
  } else {
    endLine = fullLine(end, rest);
    return [new Source(text + rest.substring(0, end.index + endLine.length), offset, text.match(srcStartRE)[SRC_NAME], info, infoPos, rest.substring(0, end.index), text.length), rest.substring(end.index + endLine.length)];
  }
};

parseHtmlBlock = function(text, offset, rest, match) {
  var end, endLine, line, otherHtmlStart;
  end = rest.match(htmlEndRE);
  otherHtmlStart = rest.match(htmlStartRE);
  line = text.match(/^.*\n/);
  if (!line) {
    line = [text];
  }
  if (!end || (otherHtmlStart && otherHtmlStart.index < end.index)) {
    return [new Meat(line[0]), text.substring(line[0].length) + rest];
  } else {
    endLine = fullLine(end, rest);
    return [new HTML(text + rest.substring(0, end.index + endLine.length), offset, match[HTML_START_NAME], line[0].length, text.length + end.index - line[0].length, match[HTML_INFO]), rest.substring(end.index + endLine.length)];
  }
};

parseList = function(match, text, offset, level, check, info, rest) {
  var children, contentOffset, inside, insideOffset, node, _ref1;
  contentOffset = listContentOffset(match);
  insideOffset = offset + contentOffset;
  inside = text.substring(contentOffset);
  children = [];
  while (inside) {
    _ref1 = parseMeat(inside, insideOffset, '', true), node = _ref1[0], inside = _ref1[1];
    while (node) {
      children.push(node);
      insideOffset += node.allText().length;
      node = node.next;
    }
  }
  return [new ListItem(text, offset, level, check === 'X' || (check === ' ' ? false : null), contentOffset, children), rest];
};

listContentOffset = function(match) {
  var _ref1, _ref2;
  return match[LIST_LEVEL].length + match[LIST_BOILERPLATE].length + ((_ref1 = (_ref2 = match[LIST_CHECK]) != null ? _ref2.length : void 0) != null ? _ref1 : 0);
};

markupText = function(text) {};

root.parseOrgMode = parseOrgMode;

root.Node = Node;

root.Headline = Headline;

root.Fragment = Fragment;

root.Meat = Meat;

root.Keyword = Keyword;

root.Source = Source;

root.HTML = HTML;

root.Results = Results;

root.resultsRE = resultsRE;

root.ListItem = ListItem;

root.SimpleMarkup = SimpleMarkup;

root.Link = Link;

root.Drawer = Drawer;

root.drawerRE = drawerRE;

root.headlineRE = headlineRE;

root.HL_TAGS = HL_TAGS;

root.parseTags = parseTags;

root.matchLine = matchLine;

root.keywordRE = keywordRE;

root.KW_BOILERPLATE = KW_BOILERPLATE;

root.KW_NAME = KW_NAME;

root.srcStartRE = srcStartRE;

root.SRC_BOILERPLATE = SRC_BOILERPLATE;

root.SRC_INFO = SRC_INFO;

root.nextOrgNode = nextOrgNode;

root.AttrHtml = AttrHtml;

if (typeof module !== "undefined" && module !== null) {
  module.exports = root;
}

//# sourceMappingURL=org.map

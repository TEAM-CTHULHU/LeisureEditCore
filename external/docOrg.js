// Generated by CoffeeScript 1.7.1
var Drawer, HTML, Headline, Keyword, Meat, Results, Source, checkMerged, checkSingleNode, createChildrenDocs, createCodeBlockDoc, createDocFromOrg, createHtmlBlockDoc, createOrgDoc, crnl, docRoot, dump, getCodeItems, getSourceNodeType, isCodeBlock, isMergeable, isSourceEnd, isYaml, lineCodeBlockType, linkDocs, orgDoc, parseOrgMode, replaceOrgDoc, root, safeLoad, _L, _ref, _ref1;

root = (_ref = typeof require === "function" ? require('./org') : void 0) != null ? _ref : Org;

Headline = root.Headline, Source = root.Source, HTML = root.HTML, Keyword = root.Keyword, Drawer = root.Drawer, Meat = root.Meat, Results = root.Results, parseOrgMode = root.parseOrgMode;

_ref1 = typeof Yaml !== "undefined" && Yaml !== null ? Yaml : typeof require === "function" ? require('./yaml') : void 0, safeLoad = _ref1.safeLoad, dump = _ref1.dump;

_L = typeof Lazy !== "undefined" && Lazy !== null ? Lazy : typeof require === "function" ? require('./lazy') : void 0;

getCodeItems = function(org) {
  var result, type;
  if (!getSourceNodeType(org)) {
    return {};
  } else {
    result = {};
    while (!isSourceEnd(org)) {
      if (type = getSourceNodeType(org)) {
        if (!result.first) {
          result.first = org;
        } else if (type === 'name') {
          return result;
        }
        if (result[type] != null) {
          return result;
        }
        result.last = result[type] = org;
        if (type === 'results') {
          break;
        }
      } else if (org instanceof Drawer || org instanceof Keyword) {
        break;
      }
      org = org.next;
    }
    if (result.source) {
      return result;
    } else {
      return {};
    }
  }
};

isCodeBlock = function(org) {
  var first;
  if (org instanceof Keyword && org.name.match(/^name$/i)) {
    first = getCodeItems(org).first;
    return first;
  } else {
    return org instanceof Source;
  }
};

getSourceNodeType = function(org) {
  if (org instanceof Source) {
    return 'source';
  } else if (org instanceof Results) {
    return 'results';
  } else if (org instanceof Drawer && org.name.toLowerCase() === 'expected') {
    return 'expected';
  } else if (org instanceof Keyword && org.name.match(/^name$/i)) {
    return 'name';
  } else {
    return false;
  }
};

isSourceEnd = function(org) {
  return !org || org instanceof Headline;
};

createDocFromOrg = function(org, collection, reloading, filter) {
  var block, doc;
  doc = orgDoc(org);
  if (filter != null) {
    doc = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = doc.length; _i < _len; _i++) {
        block = doc[_i];
        _results.push(filter(block));
      }
      return _results;
    })();
  }
  replaceOrgDoc(doc, collection, reloading);
  return collection;
};

docRoot = function(collection) {
  var _ref2, _ref3;
  return (_ref2 = ((_ref3 = collection.leisure) != null ? _ref3 : collection.leisure = {}).info) != null ? _ref2 : (collection.leisure.info = collection.findOne({
    info: true
  }));
};

replaceOrgDoc = function(docArray, collection, reloading) {
  var doc, info, _i, _len, _results;
  if (reloading) {
    collection.remove({
      info: {
        '$exists': false
      }
    });
  } else {
    collection.remove();
  }
  linkDocs(docArray);
  if (reloading) {
    info = collection.leisure.info;
    info.head = docArray.length > 0 ? docArray[0]._id : null;
    collection.update(info._id, info);
  } else {
    info = collection.leisure.info = {
      info: true,
      head: docArray.length > 0 ? docArray[0]._id : null,
      _id: new Meteor.Collection.ObjectID().toJSONValue()
    };
    collection.insert(info);
  }
  _results = [];
  for (_i = 0, _len = docArray.length; _i < _len; _i++) {
    doc = docArray[_i];
    _results.push(collection.insert(doc));
  }
  return _results;
};

linkDocs = function(docs) {
  var doc, prev, _i, _len, _results;
  prev = null;
  _results = [];
  for (_i = 0, _len = docs.length; _i < _len; _i++) {
    doc = docs[_i];
    doc._id = new Meteor.Collection.ObjectID().toJSONValue();
    if (prev) {
      prev.next = doc._id;
      doc.prev = prev._id;
    }
    _results.push(prev = doc);
  }
  return _results;
};

orgDoc = function(org) {
  return createOrgDoc(org, false)[0].toArray();
};

lineCodeBlockType = function(line) {
  var type;
  type = line && root.matchLine(line);
  if (type === 'srcStart' || type === 'srcEnd' || type === 'htmlStart' || type === 'htmlEnd') {
    return 'code';
  } else if (line.match(/^#+name:/i)) {
    return 'code';
  } else if (type === 'headline-1') {
    return 'headline';
  } else {
    return 'chunk';
  }
};

createOrgDoc = function(org, local) {
  var children, next, result, _ref2, _ref3;
  next = org.next;
  if (org instanceof Headline) {
    local = local || (org.level === 1 && org.properties.local);
    children = createChildrenDocs(org, local);
    result = org.level === 0 ? (org.children.length && children) || _L([
      {
        text: '\n',
        type: 'chunk',
        offset: org.offset
      }
    ]) : _L([
      {
        text: org.text,
        type: 'headline',
        level: org.level,
        offset: org.offset,
        properties: org.properties
      }
    ]).concat(children);
  } else if (org instanceof HTML) {
    _ref2 = createHtmlBlockDoc(org), result = _ref2[0], next = _ref2[1];
  } else if (isCodeBlock(org)) {
    _ref3 = createCodeBlockDoc(org), result = _ref3[0], next = _ref3[1];
  } else {
    result = _L([
      {
        text: org.allText(),
        type: 'chunk',
        offset: org.offset
      }
    ]);
  }
  if (local) {
    result.each(function(item) {
      return item.local = true;
    });
  }
  return [result, next];
};

createChildrenDocs = function(org, local) {
  var child, childDoc, children, mergedText, offset, _ref2, _ref3, _ref4;
  children = _L();
  child = org.children[0];
  if (child) {
    mergedText = '';
    offset = org.children[0].offset;
    while (child) {
      if (isMergeable(child)) {
        mergedText += child.allText();
        child = child.next;
      } else {
        _ref2 = checkMerged(mergedText, children, offset), mergedText = _ref2[0], children = _ref2[1];
        _ref3 = createOrgDoc(child, local), childDoc = _ref3[0], child = _ref3[1];
        children = children.concat([childDoc]);
        offset = child != null ? child.offset : void 0;
      }
    }
    _ref4 = checkMerged(mergedText, children, offset), mergedText = _ref4[0], children = _ref4[1];
  }
  return children;
};

isMergeable = function(org) {
  return !(org instanceof Headline || org instanceof HTML || isCodeBlock(org));
};

checkMerged = function(mergedText, children, offset) {
  if (mergedText !== '') {
    children = children.concat([
      {
        text: mergedText,
        type: 'chunk',
        offset: offset
      }
    ]);
  }
  return ['', children];
};

createCodeBlockDoc = function(org) {
  var err, expected, first, firstOffset, l, last, name, obj, results, source, text, _ref2, _ref3;
  text = '';
  _ref2 = getCodeItems(org), first = _ref2.first, name = _ref2.name, source = _ref2.source, last = _ref2.last, expected = _ref2.expected, results = _ref2.results;
  if (!first) {
    return [
      _L([
        {
          text: org.allText(),
          type: 'chunk',
          offset: org.offset
        }
      ]), org.next
    ];
  } else {
    firstOffset = first.offset;
    while (first !== last.next) {
      text += first.allText();
      first = first.next;
    }
    obj = {
      text: text,
      type: 'code',
      offset: firstOffset
    };
    obj.codeAttributes = source.attributes();
    obj.codePrelen = source.contentPos + source.offset - firstOffset;
    obj.codePostlen = text.length - obj.codePrelen - source.content.length;
    if (expected) {
      obj.codeContent = source.content;
      obj.codeTestActual = results.content();
      obj.codeTextExpected = expected.content();
      obj.codeTestResult = !results ? 'unknown' : expected.content() === results.content() ? 'pass' : 'fail';
    }
    if (name) {
      obj.codeName = name.info.trim();
    }
    if (((_ref3 = obj.codeAttributes) != null ? _ref3.local : void 0) != null) {
      obj.local = true;
    }
    if (l = source.lead()) {
      obj.language = l.trim();
    }
    if (isYaml(source)) {
      try {
        obj.yaml = safeLoad(source.content);
      } catch (_error) {
        err = _error;
        obj.yaml = null;
      }
    }
    return [_L([obj]), last.next];
  }
};

createHtmlBlockDoc = function(org) {
  var a, obj, text;
  text = org.allText();
  obj = {
    text: text,
    type: 'code',
    offset: org.offset
  };
  obj.codePrelen = org.contentPos;
  obj.codePostlen = text.length - obj.codePrelen - org.contentLength;
  obj.language = 'html';
  if (a = org.attributes()) {
    obj.codeAttributes = a;
  }
  return [_L([obj]), org.next];
};

isYaml = function(org) {
  return org instanceof Source && org.info.match(/^ *yaml\b/i);
};

checkSingleNode = function(text) {
  var docJson, docs, org;
  docs = {};
  org = parseOrgMode(text);
  docJson = (org.children.length > 1 ? orgDoc(org) : orgDoc(org.children[0]))[0];
  return docJson;
};

crnl = function(data) {
  if (typeof data === 'string') {
    return data.replace(/\r\n/g, '\n');
  } else if (data.text) {
    data.text = crnl(data.text);
    return data;
  } else {
    return data;
  }
};

root.getCodeItems = getCodeItems;

root.isCodeBlock = isCodeBlock;

root.createDocFromOrg = createDocFromOrg;

root.checkSingleNode = checkSingleNode;

root.orgDoc = orgDoc;

root.docRoot = docRoot;

root.linkDocs = linkDocs;

root.isYaml = isYaml;

root.crnl = crnl;

root.lineCodeBlockType = lineCodeBlockType;

if (typeof module !== "undefined" && module !== null) {
  module.exports = root;
}

//# sourceMappingURL=docOrg.map

// Generated by CoffeeScript 2.5.1
var _L, checkMerged, checkProps, createChildrenDocs, createCodeBlockDoc, createHtmlBlockDoc, createOrgDoc, dump, escapeRegexp, findTitle, getSourceNodeType, isMergeable, isSourceEnd, isYamlResult, load, replaceOrgDoc, safeLoad,
  indexOf = [].indexOf;

import {
  Headline,
  Source,
  HTML,
  Keyword,
  Drawer,
  Meat,
  UnknownDeclaration,
  Results,
  parseOrgMode,
  Fragment
} from './org.js';

import {
  Lazy
} from './lazy.js';

_L = Lazy;

({safeLoad, load, dump} = jsyaml);

export var ParsedCodeBlock = class ParsedCodeBlock {
  constructor(block) {
    if (typeof block === 'string') {
      this.setBlockText(block);
    } else {
      this.init(block);
    }
  }

  clone() {
    return new ParsedCodeBlock(this.block);
  }

  getOrg() {
    return blockOrg(this.block);
  }

  toString() {
    return `Parsed:\n  ${this.block.text.replace(/\n/g, '\n  ')}`;
  }

  init(block1) {
    var org;
    this.block = block1;
    org = blockOrg(this.block);
    if (org instanceof Fragment || org instanceof Headline) {
      org = org.children[0];
    }
    return this.items = getCodeItems(org);
  }

  setBlockText(str) {
    var bl, ref;
    if ((bl = orgDoc(parseOrgMode(str.replace(/\r\n/g, '\n')))).length !== 1 || bl[0].text !== str) {
      throw new Error(`Bad code block: '${str}'`);
    }
    bl[0]._id = (ref = this.block) != null ? ref._id : void 0;
    return this.init(bl[0]);
  }

  spliceItem(itemName, str) {
    var item;
    if (str && _.last(str) !== '\n') {
      str += '\n';
    }
    item = this.items[itemName];
    return this.setBlockText(item ? this.block.text.substring(0, item.offset) + str + this.block.text.substring(item.offset + item.text.length) : this.block.text + `#+${itemName.toUpperCase()}:\n${str}`);
  }

  setCodeInfo(info) {
    var infoStart, source, text;
    ({text} = this.block);
    ({source} = this.items);
    infoStart = source.offset + source.infoPos;
    return this.setBlockText(text.substring(0, infoStart) + info + text.substring(infoStart + source.info.length));
  }

  setCodeAttribute(name, value) {
    var info, m, prefix, ref, ref1, suffix;
    info = (ref = this.items.source.info) != null ? ref : '';
    return this.setCodeInfo(((ref1 = this.block.codeAttributes) != null ? ref1[name.toLowerCase()] : void 0) != null ? (m = info.match(new RegExp(`^((|.*\\S)(\\s*))(:${escapeRegexp(name)})((\\s+[^:]*)?(?=:|$))`, 'i')), prefix = m.index + m[1].length + m[4].length, suffix = info.substring(prefix + m[5].length), suffix ? suffix = ' ' + suffix : void 0, value == null ? info.substring(0, m.index + m[2].length) + suffix : info.substring(0, prefix) + ' ' + value + suffix) : value == null ? info : info + ` :${name}` + (value ? ' ' + value : ''));
  }

  setResults(str) {
    return this.spliceItem('results', str);
  }

  setSource(str) {
    return this.spliceItem('source', str);
  }

  setError(str) {
    return this.spliceItem('error', str);
  }

  addResultType(str) {
    var ref, results, types;
    types = this.getResultTypes();
    if (!(indexOf.call(types, str) >= 0)) {
      results = (ref = this.block.codeAttributes) != null ? ref.results : void 0;
      return this.setCodeAttribute('results', results ? `${results} ${str}` : str);
    }
  }

  removeResultType(str) {
    var end, i, j, k, len, prefix, ref, ref1, ref2, ref3, ref4, res, start, types, values;
    res = (ref = this.block.codeAttributes) != null ? ref.results : void 0;
    types = this.getResultTypes();
    if (ref1 = str.toLowerCase(), indexOf.call(types, ref1) >= 0) {
      values = res.toLowerCase().split(/(\s+)/);
      start = values.indexOf(str.toLowerCase());
      end = start + 1;
      if (start > 0) {
        start--;
      } else if (end < values.length) {
        end++;
      }
      prefix = 0;
      for (i = j = 0, ref2 = start; (0 <= ref2 ? j < ref2 : j > ref2); i = 0 <= ref2 ? ++j : --j) {
        prefix += values[i].length;
      }
      len = 0;
      for (i = k = ref3 = start, ref4 = end; (ref3 <= ref4 ? k < ref4 : k > ref4); i = ref3 <= ref4 ? ++k : --k) {
        len += values[i].length;
        values[i] = false;
      }
      return this.setCodeAttribute('results', _.some(values) ? res.substring(0, prefix) + res.substring(prefix + len) : void 0);
    }
  }

  setResultView(viewStr) {
    var m, newRes, ref, res;
    if (viewStr) {
      viewStr = ' ' + viewStr;
    }
    res = (ref = this.block.codeAttributes) != null ? ref.results : void 0;
    newRes = (m = res.match(/\s*\bview(\(.*\)|\b)/)) ? res.substring(0, m.index) + viewStr + res.substring(m.index + m[0].length) : viewStr ? res + viewStr : res;
    return this.setCodeAttribute('results', newRes);
  }

  setExports(code, results) {
    return this.setCodeAttribute('exports', !code || !results ? (code && 'code') || (results && 'results') || 'none' : void 0);
  }

  exportsCode() {
    var ref;
    return (ref = this.getExports()) === 'code' || ref === 'both';
  }

  exportsResults() {
    var ref;
    return (ref = this.getExports()) === 'results' || ref === 'both';
  }

  getExports() {
    var ref, ref1;
    return ((ref = this.block.codeAttributes) != null ? (ref1 = ref.exports) != null ? ref1.toLowerCase() : void 0 : void 0) || 'both';
  }

  getResultTypes() {
    var ref, ref1, ref2;
    return (ref = (ref1 = this.block.codeAttributes) != null ? (ref2 = ref1.results) != null ? ref2.toLowerCase().split(' ') : void 0 : void 0) != null ? ref : [];
  }

  setDynamic(state) {
    if (this.isDynamic() !== state) {
      if (state) {
        return this.addResultType('dynamic');
      } else {
        return this.removeResultType('dynamic');
      }
    }
  }

  isDynamic() {
    return indexOf.call(this.getResultTypes(), 'dynamic') >= 0;
  }

  setSourceContent(newContent) {
    var src;
    src = this.items.source;
    return this.setSource(`${src.text.substring(0, src.contentPos)}${newContent}${src.text.substring(src.contentPos + src.content.length)}`);
  }

  hasExpected() {
    return this.items.expected;
  }

  resultsAreExpected() {
    return this.items.expected && this.items.results && this.items.expected.content() === this.items.results.content();
  }

  makeResultsExpected() {
    var item, newExpected, source;
    if (this.items.results) {
      newExpected = `:expected:\n${this.items.results.content()}:end:\n`;
      item = this.items.expected;
      return this.setBlockText(item ? this.block.text.substring(0, item.offset) + newExpected + this.block.text.substring(item.offset + item.text.length) : (source = this.items.source, this.block.text.substring(0, source.offset + source.text.length) + newExpected + this.block.text.substring(source.offset + source.text.length)));
    }
  }

  clearExpected() {
    var item;
    if (item = this.items.expected) {
      return this.setBlockText(this.block.text.substring(0, item.offset) + this.block.text.substring(item.offset + item.text.length));
    }
  }

};

escapeRegexp = function(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

export var blockOrg = function(block) {
  var frag, org, text;
  text = typeof block === 'string' ? block : block.text;
  org = parseOrgMode(text);
  org = org.children.length === 1 ? org.children[0] : (frag = new Fragment(org.offset, org.children), frag);
  if (typeof block === 'object') {
    org.nodeId = block._id;
    org.shared = block.type;
  }
  org.linkNodes();
  return org;
};

export var getCodeItems = function(org) {
  var result, type;
  if (!getSourceNodeType(org)) {
    return {};
  } else {
    result = {};
    while (!isSourceEnd(org)) {
      if (type = getSourceNodeType(org)) {
        if (type === 'html') {
          if (result.first) {
            return result;
          } else {
            return {
              source: org,
              first: org,
              last: org
            };
          }
        }
        if (!result.first) {
          result.first = org;
        } else if (type === 'name') {
          return result;
        }
        if (result[type] != null) {
          return result;
        }
        result.last = result[type] = org;
        if (type === 'name' && org.next.constructor === Meat && org.next.next instanceof Source) {
          result.doc = org.next;
        }
        if (type === 'results') {
          break;
        }
      } else if (org instanceof Drawer || org instanceof Keyword || org instanceof UnknownDeclaration) {
        break;
      }
      org = org.next;
    }
    if (result.source) {
      return result;
    } else {
      return {};
    }
  }
};

export var isCodeBlock = function(org) {
  var first;
  if (org instanceof Keyword && org.name.match(/^name$/i)) {
    ({first} = getCodeItems(org));
    return first;
  } else {
    return org instanceof Source;
  }
};

getSourceNodeType = function(org) {
  if (org instanceof Source) {
    return 'source';
  } else if (org instanceof HTML) {
    return 'html';
  } else if (org instanceof Results) {
    return 'results';
  } else if (org instanceof Drawer && org.name.toLowerCase() === 'expected') {
    return 'expected';
  } else if (org instanceof Keyword && org.name.match(/^name$/i)) {
    return 'name';
  } else if (org instanceof Keyword && org.name.match(/^error$/i)) {
    return 'error';
  } else {
    return false;
  }
};

isSourceEnd = function(org) {
  return !org || org instanceof Headline;
};

export var createDocFromOrg = function(org, collection, reloading, filter) {
  var doc;
  doc = orgDoc(org);
  if (filter != null) {
    doc = _.map(doc, filter);
  }
  replaceOrgDoc(doc, collection, reloading);
  return collection;
};

export var docRoot = function(collection) {
  var ref, ref1;
  return (ref = ((ref1 = collection.leisure) != null ? ref1 : collection.leisure = {}).info) != null ? ref : (collection.leisure.info = collection.findOne({
    info: true
  }));
};

replaceOrgDoc = function(docArray, collection, reloading) {
  var doc, info, j, len1, results1;
  if (reloading) {
    collection.remove({
      info: {
        '$exists': false
      }
    });
  } else {
    collection.remove();
  }
  linkDocs(docArray);
  //console.log "DOCS: #{JSON.stringify docArray, null, '  '}"
  if (reloading) {
    info = collection.leisure.info;
    info.head = docArray.length > 0 ? docArray[0]._id : null;
    collection.update(info._id, info);
  } else {
    info = collection.leisure.info = {
      info: true,
      head: docArray.length > 0 ? docArray[0]._id : null,
      _id: new Meteor.Collection.ObjectID().toJSONValue()
    };
    collection.insert(info);
  }
  results1 = [];
  for (j = 0, len1 = docArray.length; j < len1; j++) {
    doc = docArray[j];
    results1.push(collection.insert(doc));
  }
  return results1;
};

export var linkDocs = function(docs) {
  var doc, j, len1, prev, results1;
  prev = null;
  results1 = [];
  for (j = 0, len1 = docs.length; j < len1; j++) {
    doc = docs[j];
    doc._id = new Meteor.Collection.ObjectID().toJSONValue();
    if (prev) {
      prev.next = doc._id;
      doc.prev = prev._id;
    }
    results1.push(prev = doc);
  }
  return results1;
};

export var orgDoc = function(org, withProperties) {
  return createOrgDoc(org, false, withProperties)[0].toArray();
};

export var lineCodeBlockType = function(line) {
  var type;
  type = line && root.matchLine(line);
  if (type === 'srcStart' || type === 'srcEnd' || type === 'htmlStart' || type === 'htmlEnd') {
    return 'code';
  } else if (line.match(/^#+name:/i)) {
    return 'code';
  } else if (type === 'headline-1') {
    return 'headline';
  } else {
    return 'chunk';
  }
};

createOrgDoc = function(org, local, withProps) {
  var block, children, next, result, title;
  next = org.next;
  if (org instanceof Headline) {
    local = local || (org.level === 1 && org.properties.local);
    children = createChildrenDocs(org, local, withProps);
    result = org.level === 0 ? (org.children.length && children) || _L([
      {
        text: '\n',
        type: 'chunk',
        offset: org.offset
      }
    ]) : _L([
      {
        text: org.text,
        type: 'headline',
        level: org.level,
        offset: org.offset,
        properties: org.properties
      }
    ]).concat(children);
  } else if (org instanceof HTML) {
    [result, next] = createHtmlBlockDoc(org);
  } else if (isCodeBlock(org)) {
    [result, next] = createCodeBlockDoc(org);
  } else {
    block = {
      text: org.allText(),
      type: 'chunk',
      offset: org.offset
    };
    if (title = findTitle(org)) {
      block.title = title;
    }
    result = _L(checkProps(org, [block]));
  }
  block = result.last();
  if (withProps && block.type === 'code') {
    block.properties = org.allProperties();
  }
  if (local) {
    result.each(function(item) {
      return item.local = true;
    });
  }
  return [result, next];
};

findTitle = function(org) {
  var child, j, len1, ref, title;
  if (org instanceof Keyword && org.name.toLowerCase() === 'title') {
    return org.info.trim();
  } else if (org.children) {
    ref = org.children;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      child = ref[j];
      if (title = findTitle(child)) {
        return title;
      }
    }
  }
};

checkProps = function(org, block) {
  if (typeof org.isProperties === "function" ? org.isProperties() : void 0) {
    return block.properties = org.properties();
  }
};

createChildrenDocs = function(org, local, withProps) {
  var child, childDoc, children, mergedText, newTitle, offset, properties, title;
  children = _L();
  child = org.children[0];
  title = null;
  if (child) {
    mergedText = '';
    properties = _L();
    offset = org.children[0].offset;
    while (child) {
      if (newTitle = findTitle(child)) {
        title = newTitle;
      }
      if (isMergeable(child)) {
        mergedText += child.allText();
        if (typeof child.properties === "function" ? child.properties() : void 0) {
          properties = properties.merge(typeof child.properties === "function" ? child.properties() : void 0);
        }
        child = child.next;
      } else {
        [mergedText, properties, children] = checkMerged(mergedText, properties, children, offset);
        [childDoc, child] = createOrgDoc(child, local, withProps);
        if (title) {
          (children.isEmpty() ? childDoc : children).first().title = title;
          title = null;
        }
        children = children.concat([childDoc]);
        offset = child != null ? child.offset : void 0;
      }
    }
    [mergedText, properties, children] = checkMerged(mergedText, properties, children, offset, title);
  }
  return children;
};

isMergeable = function(org) {
  return !(org instanceof Headline || org instanceof HTML || isCodeBlock(org));
};

checkMerged = function(mergedText, properties, children, offset, title) {
  var child;
  if (mergedText !== '') {
    child = {
      text: mergedText,
      type: 'chunk',
      offset: offset
    };
    if (title) {
      child.title = title;
    }
    if (!properties.isEmpty()) {
      child.properties = properties.toObject();
    }
    children = children.concat([child]);
  }
  return ['', _L(), children];
};

createCodeBlockDoc = function(org) {
  var attr, expected, first, firstOffset, l, last, name, nm, obj, ref, ref1, results, source, text, val, yamlSrc;
  text = '';
  ({first, name, source, last, expected, results} = getCodeItems(org));
  if (!first) {
    return [
      _L([
        {
          text: org.allText(),
          type: 'chunk',
          offset: org.offset
        }
      ]),
      org.next
    ];
  } else {
    firstOffset = first.offset;
    while (first !== last.next) {
      text += first.allText();
      first = first.next;
    }
    obj = {
      text: text,
      type: 'code',
      offset: firstOffset
    };
    if (source.attributes()) {
      attr = {};
      ref = source.attributes();
      for (nm in ref) {
        val = ref[nm];
        attr[nm.toLowerCase()] = val;
      }
    } else {
      attr = null;
    }
    obj.codeAttributes = attr;
    obj.codePrelen = source.contentPos + source.offset - firstOffset;
    obj.codePostlen = text.length - obj.codePrelen - source.content.length;
    if (expected) {
      obj.codeContent = source.content;
      obj.codeTestActual = results.content();
      obj.codeTestExpected = expected.content();
      obj.codeTestResult = !results ? 'unknown' : expected.content() === results.content() ? 'pass' : 'fail';
    }
    if (name) {
      obj.codeName = name.info.trim();
    }
    if (((ref1 = obj.codeAttributes) != null ? ref1.local : void 0) != null) {
      obj.local = true;
    }
    if (l = source.lead()) {
      obj.language = l.trim();
    }
    if (isYamlResult(obj) || isYaml(source)) {
      yamlSrc = (isYaml(source) && !results ? source.content : (obj.computedYaml = true, results != null ? results.content().replace(/^: /gm, '') : void 0));
      if (yamlSrc) {
        obj.yaml = parseYaml(yamlSrc);
      }
    } else if (isText(source)) {
      obj.yaml = source.content;
    }
    return [_L([obj]), last.next];
  }
};

export var parseYaml = function(str) {
  var err;
  try {
    //safeLoad str
    return load(str);
  } catch (error) {
    err = error;
    return void 0;
  }
};

createHtmlBlockDoc = function(org) {
  var a, obj, text;
  text = org.allText();
  obj = {
    text: text,
    type: 'code',
    offset: org.offset
  };
  obj.codePrelen = org.contentPos;
  obj.codePostlen = text.length - obj.codePrelen - org.contentLength;
  obj.language = 'html';
  if (a = org.attributes()) {
    obj.codeAttributes = a;
  }
  return [_L([obj]), org.next];
};

export var isYaml = function(org) {
  return org instanceof Source && org.info.match(/^ *yaml\b/i);
};

isYamlResult = function(block) {
  var ref, ref1, ref2;
  return ((ref = block.codeAttributes) != null ? (ref1 = ref.results) != null ? ref1.match(/\byaml\b/) : void 0 : void 0) || ((ref2 = block.codeAttributes) != null ? ref2.post : void 0);
};

export var isText = function(org) {
  return org instanceof Source && org.info.match(/^ *(text|string)\b/i);
};

export var checkSingleNode = function(text) {
  var docJson, docs, org;
  docs = {};
  org = parseOrgMode(text);
  [docJson] = org.children.length > 1 ? orgDoc(org) : orgDoc(org.children[0]);
  //if docJson.children? then console.log "NEW NODE\n#{JSON.stringify docJson}"
  return docJson;
};

export var crnl = function(data) {
  if (typeof data === 'string') {
    return data.replace(/\r\n/g, '\n');
  } else if (data.text) {
    data.text = crnl(data.text);
    return data;
  } else {
    return data;
  }
};

export var blockSource = function(block) {
  return block && block.text.substring(block.codePrelen, block.text.length - block.codePostlen);
};

//{
//  getCodeItems
//  isCodeBlock
//  createDocFromOrg
//  checkSingleNode
//  orgDoc
//  docRoot
//  linkDocs
//  isYaml
//  isText
//  crnl
//  lineCodeBlockType
//  blockSource
//  ParsedCodeBlock
//  blockOrg
//  parseYaml
//}

//# sourceMappingURL=docOrg.js.map

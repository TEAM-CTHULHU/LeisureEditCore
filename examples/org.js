// Generated by CoffeeScript 2.5.1
/*
Copyright (C) 2013, 2021, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/
var ATTR_NAME, DRAWER_NAME, END_NAME, HTML_INFO, HTML_START_NAME, LINK_DESCRIPTION, LINK_HEAD, LINK_INFO, LIST_BOILERPLATE, LIST_CHECK, LIST_CHECK_VALUE, LIST_INFO, LIST_LEVEL, MeatParser, PROPERTY_KEY, PROPERTY_VALUE, RES_NAME, SRC_NAME, _, attrHtmlLineRE, attrHtmlRE, buildHeadlineRE, checkMatch, declRE, endRE, exampleEndRE, exampleStartRE, fullLine, htmlEndRE, htmlStartRE, imagePathRE, inListItem, keywordPropertyRE, last, leisurePathRE, lineBreakPat, linkRE, listContentOffset, listRE, markupText, markupTypes, meatStart, parseAttr, parseDrawer, parseExample, parseHeadline, parseHtmlBlock, parseKeyword, parseList, parseOrgChunk, parseRestOfMeat, parseResults, parseSrcBlock, parseUnknown, propertyRE, resultsLineRE, simpleRE, srcEndRE, tagsRE, todoKeywords, todoRE;

import {
  
  // Parse orgmode files

  // alText() gets its text, plus its childrens'

  Lazy
} from './lazy.js';

_ = Lazy;

todoKeywords = ['TODO', 'DONE'];

declRE = /^#\+.*$/m;

buildHeadlineRE = function() {
  return new RegExp(`^(\\*+( +|$))((?:${todoKeywords.join('|')}) *)?(\\[#(A|B|C)\\] *)?([^\\n]*?)(:[\\w@%#:]*: *)?$`, 'm');
};

export var HL_LEVEL = 1;

export var HL_TODO = 3;

export var HL_PRIORITY = 5;

export var HL_TEXT = 6;

export var HL_TAGS = 7;

export var headlineRE = buildHeadlineRE();

todoRE = /^(\*+) *(TODO|DONE)/;

tagsRE = /:[^:]*/;

export var KW_BOILERPLATE = 1;

export var KW_NAME = 2;

export var KW_INFO = 3;

export var keywordRE = /^(#\+([^:\[\n]+)(?:\[.*\] *)?: *)([^\n]*)$/im;

export var SRC_BOILERPLATE = 1;

SRC_NAME = 2;

export var SRC_INFO = 3;

export var srcStartRE = /^(#\+(BEGIN_SRC) +)([^\n]*)$/im;

END_NAME = 1;

srcEndRE = /^#\+(END_SRC)( *)$/im;

exampleStartRE = /^#\+BEGIN_EXAMPLE *$/im;

exampleEndRE = /^#\+END_EXAMPLE *$/im;

RES_NAME = 1;

export var resultsRE = /^#\+(RESULTS)(?: *\[.*\] *)?: *$/im;

resultsLineRE = /^([:|] .*)(?:\n|$)/i;

DRAWER_NAME = 1;

export var drawerRE = /^ *:([^\n:]*): *$/im;

endRE = /^ *:END: *$/im;

PROPERTY_KEY = 1;

PROPERTY_VALUE = 2;

propertyRE = /^ *:([^\n:]+): *([^\n]*)$/img;

LIST_LEVEL = 1;

LIST_BOILERPLATE = 2;

LIST_CHECK = 3;

LIST_CHECK_VALUE = 4;

LIST_INFO = 5;

listRE = /^( *)(- *)(\[( |X)\] +)?(.*)$/m;

// markup characters: * / + = ~ _
//simpleRE = /\B(\*[/+=~\w](.*?[/+=~\w])?\*|\/[*+=~\w](.*?[*+=~\w])?\/|\+[*/=~\w](.*?[*/=~\w])?\+|=[+*/~\w](.*?[+*/~\w])?=|~[=+*/\w](.*?[=+*/\w])?~)(\B|$)|\b_[^_]*\B_(\b|$)/
//simpleRE = /\B(\*[/+=~\S](.*?[/+=~\S])?\*|\/[*+=~\S](.*?[*+=~\S])?\/|\+[*/=~\S](.*?[*/=~\S])?\+|=[+*/~\S](.*?[+*/~\S])?=|~[=+*/\S](.*?[=+*/\S])?~)(\B|$)|\b_[^_]*\B_(\b|$)/
simpleRE = /\B(\*[^\s*]([^*]*[^\s*])?\*|\/[^\s\/]([^\/]*[^\s\/])?\/|\+[^\s+]([^+]*[^\s+])?\+|=[^\s=]([^=]*[^\s=])?=|~[^\s~]([^~]*[^\s~])?~)(\B|$)|\b_[^_]*\B_(\b|$)/;

LINK_HEAD = 1;

LINK_INFO = 2;

LINK_DESCRIPTION = 3;

linkRE = /(\[\[([^\]]*)\])(?:\[([^\]]*)\])?\]/;

htmlStartRE = /^#\+(BEGIN_HTML\b)(.*)$/im;

HTML_START_NAME = 1;

HTML_INFO = 2;

htmlEndRE = /^#\+END_HTML *$/im;

ATTR_NAME = 1;

attrHtmlRE = /^#\+(ATTR_HTML): *$/im;

attrHtmlLineRE = /^([:|] .*)(?:\n|$)/i;

imagePathRE = /\.(png|jpg|jpeg|gif|svg|tiff|bmp)$/i;

leisurePathRE = /^(?:lounge|leisure):([^\/]*)(?:\/([^\/]*)(?:\/([^\/]*))?)?$/;

keywordPropertyRE = /:([^ ]+)/;

last = function(a) {
  return a[a.length - 1];
};

export var matchLine = function(txt) {
  var ref;
  if (((ref = txt.match(simpleRE)) != null ? ref.index : void 0) === 0) {
    return false;
  } else {
    return checkMatch(txt, exampleStartRE, 'exampleStart') || checkMatch(txt, exampleEndRE, 'exampleEnd') || checkMatch(txt, srcStartRE, 'srcStart') || checkMatch(txt, srcEndRE, 'srcEnd') || checkMatch(txt, resultsRE, 'results') || checkMatch(txt, attrHtmlRE, 'attr') || checkMatch(txt, keywordRE, 'keyword') || checkMatch(txt, headlineRE, function(m) {
      return `headline-${m[HL_LEVEL].trim().length}`;
    }) || checkMatch(txt, listRE, 'list') || checkMatch(txt, htmlStartRE, 'htmlStart') || checkMatch(txt, htmlEndRE, 'htmlEnd') || checkMatch(txt, declRE, 'unknownDecl');
  }
};

checkMatch = function(txt, pat, result) {
  var m;
  m = txt.match(pat);
  if ((m != null ? m.index : void 0) === 0) {
    if (typeof result === 'string') {
      return result;
    } else {
      return result(m);
    }
  } else {
    return false;
  }
};

export var Node = (function() {
  class Node {
    constructor(text1) {
      this.text = text1;
      this.markup = markupText(this.text);
    }

    count() {
      return 1;
    }

    length() {
      return this.text.length;
    }

    end() {
      return this.offset + this.text.length;
    }

    toJson() {
      return JSON.stringify(this.toJsonObject(), null, '  ');
    }

    toJsonObject() {
      var obj;
      obj = this.jsonDef();
      obj.nodeId = this.nodeId;
      return obj;
    }

    allText() {
      return this.text;
    }

    findNodeAt(pos) {
      if (this.offset <= pos && pos < this.offset + this.text.length) {
        return this;
      } else {
        return null;
      }
    }

    scan(func) {
      return func(this);
    }

    scanWithChildren(func) {
      var c, i, len, ref, results;
      func(this);
      ref = this.children;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.scan(func));
      }
      return results;
    }

    linkNodes() {
      return this;
    }

    linkChild(child) {
      child.linkNodes();
      return child.linkTo(this);
    }

    linkChildren() {
      var c, i, len, prev, ref;
      prev = null;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (prev) {
          prev.next = c;
        }
        this.linkChild(c);
        c.prev = prev;
        prev = c;
      }
      return this;
    }

    contains(node) {
      var ref;
      while (node) {
        if (node === this) {
          return true;
        }
        node = (ref = node.fragment) != null ? ref : node.parent;
      }
      return false;
    }

    top() {
      if (!this.parent) {
        return this;
      } else {
        return this.parent.top();
      }
    }

    toString() {
      return this.toJson();
    }

    allTags() {
      var ref, ref1;
      return (ref = (ref1 = this.parent) != null ? ref1.allTags() : void 0) != null ? ref : [];
    }

    allProperties() {
      var ref, ref1;
      return (ref = (ref1 = this.parent) != null ? ref1.allProperties() : void 0) != null ? ref : {};
    }

    linkTo(parent1) {
      this.parent = parent1;
    }

    fixOffsets(newOff) {
      this.offset = newOff;
      if (this.children) {
        return this.fixChildrenOffsets();
      } else {
        return newOff + this.allText().length;
      }
    }

    fixChildrenOffsets() {
      var child, i, len, offset, ref;
      offset = this.offset + this.text.length;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        offset = child.fixOffsets(offset);
      }
      return offset;
    }

    inNewMeat() {
      return false;
    }

    getRightmostDescendent() {
      var child, ref;
      child = this;
      while ((ref = child.children) != null ? ref.length : void 0) {
        child = child.children[child.children.length - 1];
      }
      return child;
    }

    getLeftmostDescendent() {
      var child, ref;
      child = this;
      while ((ref = child.children) != null ? ref.length : void 0) {
        child = child.children[0];
      }
      return child;
    }

    getPrecedingNode() {
      var parent, ref;
      if (this.prev) {
        return this.prev.getRightmostDescendent();
      } else if (parent = (ref = this.fragment) != null ? ref : this.parent) {
        if (parent.children[0] === this) {
          return parent;
        }
        return parent.children[parent.children.indexOf(this) - 1].getRightmostDescendent();
      }
    }

    getFollowingNode() {
      var parent, ref;
      if (this.next) {
        return this.next.getLeftmostDescendent();
      } else if (parent = (ref = this.fragment) != null ? ref : this.parent) {
        if (parent.children[parent.children.length - 1] === this) {
          return parent;
        }
        return parent.children[parent.children.indexOf(this) + 1].getLeftmostDescendent();
      }
    }

  };

  Node.prototype.block = false;

  Node.prototype.next = null;

  Node.prototype.prev = null;

  return Node;

}).call(this);

export var Headline = (function() {
  class Headline extends Node {
    constructor(text, level1, todo1, priority1, tags1, children1, offset1) {
      super(text);
      this.level = level1;
      this.todo = todo1;
      this.priority = priority1;
      this.tags = tags1;
      this.children = children1;
      this.offset = offset1;
      this.properties = {};
    }

    count() {
      var count, i, len, node, ref;
      count = 1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        count += node.count();
      }
      return count;
    }

    lowerThan(l) {
      return l < this.level;
    }

    length() {
      return this.end() - this.offset;
    }

    end() {
      var lastChild;
      if (this.children.length) {
        lastChild = this.children[this.children.length - 1];
        return lastChild.offset + lastChild.length();
      } else {
        return super.end();
      }
    }

    jsonDef() {
      var c;
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        level: this.level,
        todo: this.todo,
        priority: this.priority,
        tags: this.tags,
        children: (function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            results.push(c.toJsonObject());
          }
          return results;
        }).call(this),
        properties: this.properties
      };
    }

    allText() {
      var c;
      return this.text + ((function() {
        var i, len, ref, results;
        ref = this.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(c.allText());
        }
        return results;
      }).call(this)).join('');
    }

    findNodeAt(pos) {
      var child, i, len, ref, res;
      if (pos < this.offset || this.offset + this.length() < pos) {
        return null;
      } else if (pos < this.offset + this.text.length) {
        return this;
      } else {
        ref = this.children;
        // could binary search this
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (res = child.findNodeAt(pos)) {
            return res;
          }
        }
        return null;
      }
    }

    linkNodes() {
      return this.linkChildren();
    }

    addTags(set) {
      var i, len, ref, tag;
      ref = parseTags(this.tags);
      for (i = 0, len = ref.length; i < len; i++) {
        tag = ref[i];
        set[tag] = true;
      }
      return set;
    }

    addProperties(props) {
      return Object.assign(props, this.properties);
    }

    addAllTags() {
      var ref;
      return this.addTags(((ref = this.parent) != null ? ref.addAllTags() : void 0) || {});
    }

    allProperties() {
      var ref;
      return this.addProperties(((ref = this.parent) != null ? ref.allProperties() : void 0) || {});
    }

    allTags() {
      return _.keys(this.addAllTags());
    }

    parts() {
      var m, ref, ref1, ref2, ref3, ref4;
      m = this.text.match(headlineRE);
      return {
        level: ((ref = m[HL_LEVEL]) != null ? ref : '').trim().length,
        stars: (ref1 = m[HL_LEVEL]) != null ? ref1 : '',
        todo: (ref2 = m[HL_TODO]) != null ? ref2 : '',
        priority: (ref3 = m[HL_PRIORITY]) != null ? ref3 : '',
        text: m[HL_TEXT],
        tags: (ref4 = m[HL_TAGS]) != null ? ref4 : ''
      };
    }

    partOffsets() {
      var addPart, m, pos, ref, ref1, ref2, ref3, ret;
      m = this.text.match(headlineRE);
      pos = 0;
      ret = {};
      addPart = function(name, text) {
        ret[name] = {
          start: pos,
          end: pos + text.length
        };
        return pos += text.length;
      };
      addPart('stars', (ref = m[HL_LEVEL]) != null ? ref : '');
      addPart('todo', (ref1 = m[HL_TODO]) != null ? ref1 : '');
      addPart('priority', (ref2 = m[HL_PRIORITY]) != null ? ref2 : '');
      addPart('text', m[HL_TEXT]);
      addPart('tags', (ref3 = m[HL_TAGS]) != null ? ref3 : '');
      return ret;
    }

  };

  Headline.prototype.block = true;

  Headline.prototype.type = 'headline';

  Headline.prototype.scan = Node.prototype.scanWithChildren;

  return Headline;

}).call(this);

export var Fragment = (function() {
  class Fragment extends Node {
    constructor(offset1, children1) {
      super('');
      this.offset = offset1;
      this.children = children1;
    }

    count() {
      var count, i, len, node, ref;
      count = 1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        count += node.count();
      }
      return count;
    }

    end() {
      var lastChild;
      if (this.children.length) {
        lastChild = this.children[this.children.length - 1];
        return lastChild.offset + lastChild.length();
      } else {
        return super.end();
      }
    }

    length() {
      return this.end() - this.offset;
    }

    jsonDef() {
      var c;
      return {
        type: this.type,
        offset: this.offset,
        children: (function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            results.push(c.toJsonObject());
          }
          return results;
        }).call(this)
      };
    }

    allText() {
      var c;
      return this.text + ((function() {
        var i, len, ref, results;
        ref = this.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(c.allText());
        }
        return results;
      }).call(this)).join('');
    }

    findNodeAt(pos) {
      var child, i, len, ref, res;
      if (pos < this.offset || this.offset + this.length() < pos) {
        return null;
      } else if (pos < this.offset + this.text.length) {
        return this;
      } else {
        ref = this.children;
        // could binary search this
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (res = child.findNodeAt(pos)) {
            return res;
          }
        }
        return null;
      }
    }

    linkNodes() {
      return this.linkChildren();
    }

    linkChild(child) {
      child.fragment = this;
      return super.linkChild(child);
    }

    linkTo(parent) {
      var c, i, len, ref, results;
      if (this.children.length) {
        this.children[0].prev = this.prev;
        this.children[this.children.length - 1].next = this.next;
        ref = this.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(c.linkTo(parent));
        }
        return results;
      }
    }

  };

  Fragment.prototype.block = true;

  Fragment.prototype.type = 'fragment';

  return Fragment;

}).call(this);

export var Meat = (function() {
  class Meat extends Node {
    constructor(text, offset1) {
      super(text);
      this.offset = offset1;
    }

    lowerThan(l) {
      return true;
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset
      };
    }

    inNewMeat() {
      var cur, i, len, m, meat, t;
      meat = [];
      cur = this;
      while (cur && !(cur instanceof Headline || inListItem(cur))) {
        meat.push(cur);
        cur = cur.getPrecedingNode();
      }
      meat.reverse();
      t = '';
      for (i = 0, len = meat.length; i < len; i++) {
        m = meat[i];
        t += m.allText();
      }
      return t.match(meatStart);
    }

  };

  Meat.prototype.type = 'meat';

  return Meat;

}).call(this);

inListItem = function(org) {
  var ref;
  return org && (org instanceof ListItem || inListItem((ref = org.fragment) != null ? ref : org.parent));
};

meatStart = /^\S|\n\n\S/;

markupTypes = {
  '*': 'bold',
  '/': 'italic',
  '_': 'underline',
  '=': 'verbatim',
  '~': 'code',
  '+': 'strikethrough'
};

export var SimpleMarkup = (function() {
  //* bold, / italic, _ underline, = verbatim, ~ code, + strikethrough
  class SimpleMarkup extends Meat {
    constructor(text, offset, children1) {
      super(text, offset);
      this.children = children1;
      this.markupType = markupTypes[this.text[0]];
    }

    count() {
      var count, i, len, node, ref;
      count = 1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        count += node.count();
      }
      return count;
    }

    linkNodes() {
      return this.linkChildren();
    }

    jsonDef() {
      var c;
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        markupType: this.markupType,
        children: (function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            results.push(c.toJsonObject());
          }
          return results;
        }).call(this)
      };
    }

  };

  SimpleMarkup.prototype.type = 'simple';

  SimpleMarkup.prototype.scan = Node.prototype.scanWithChildren;

  return SimpleMarkup;

}).call(this);

export var Link = (function() {
  class Link extends Meat {
    constructor(text, offset, path, children1) {
      super(text, offset);
      this.path = path;
      this.children = children1;
    }

    count() {
      var count, i, len, node, ref;
      count = 1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        count += node.count();
      }
      return count;
    }

    jsonDef() {
      var c;
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        path: this.path,
        children: (function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            c = ref[i];
            results.push(c.toJsonObject());
          }
          return results;
        }).call(this)
      };
    }

    isImage() {
      return this.path.match(imagePathRE);
    }

    isLeisure() {
      return this.path.match(leisurePathRE);
    }

    descriptionText() {
      var child;
      return ((function() {
        var i, len, ref, results;
        ref = this.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          results.push(child.allText());
        }
        return results;
      }).call(this)).join(' ');
    }

  };

  Link.prototype.type = 'link';

  Link.prototype.scan = Node.prototype.scanWithChildren;

  return Link;

}).call(this);

export var ListItem = (function() {
  class ListItem extends Meat {
    constructor(text, offset, level1, checked, contentOffset1, children1) {
      super(text, offset);
      this.level = level1;
      this.checked = checked;
      this.contentOffset = contentOffset1;
      this.children = children1;
    }

    count() {
      var count, i, len, node, ref;
      count = 1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        count += node.count();
      }
      return count;
    }

    linkNodes() {
      return this.linkChildren();
    }

    jsonDef() {
      var child, obj;
      obj = {
        type: this.type,
        text: this.text,
        level: this.level,
        offset: this.offset,
        contentOffset: this.contentOffset,
        children: (function() {
          var i, len, ref, results;
          ref = this.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            results.push(child.toJsonObject());
          }
          return results;
        }).call(this)
      };
      if (this.checked != null) {
        obj.checked = this.checked;
      }
      return obj;
    }

    getParent() {
      var li;
      if (this.level === 0) {
        null;
      }
      li = this;
      while (li = li.getPreviousListItem()) {
        if (li.level < this.level) {
          return li;
        }
      }
    }

    getPreviousListItem() {
      var cur, parent, ref;
      parent = this.fragment || this.parent;
      cur = this;
      while (cur = cur.getPrecedingNode()) {
        if (!(parent.contains(cur)) || cur.inNewMeat()) {
          return null;
        }
        if (((ref = cur.fragment) != null ? ref : cur.parent) === parent && cur instanceof ListItem) {
          return cur;
        }
      }
      return null;
    }

    getNextListItem() {
      var cur, parent, ref;
      parent = this.fragment || this.parent;
      cur = this;
      while (cur = cur.getFollowingNode()) {
        if (!(parent.contains(cur)) || cur.inNewMeat()) {
          return null;
        }
        if (((ref = cur.fragment) != null ? ref : cur.parent) === parent && cur instanceof ListItem) {
          return cur;
        }
      }
      return null;
    }

    inNewMeat() {
      return true;
    }

  };

  ListItem.prototype.type = 'list';

  ListItem.prototype.scan = Node.prototype.scanWithChildren;

  return ListItem;

}).call(this);

export var Drawer = (function() {
  class Drawer extends Meat {
    constructor(text, offset, name1, contentPos1, endPos) {
      super(text, offset);
      this.name = name1;
      this.contentPos = contentPos1;
      this.endPos = endPos;
    }

    jsonDef() {
      return {
        type: this.type,
        name: this.name,
        text: this.text,
        offset: this.offset,
        contentPos: this.contentPos,
        endPos: this.endPos
      };
    }

    leading() {
      return this.text.substring(0, this.contentPos);
    }

    content() {
      return this.text.substring(this.contentPos, this.endPos);
    }

    trailing() {
      return this.text.substring(this.endPos);
    }

    isProperties() {
      return this.name.toLowerCase() === 'properties';
    }

    properties() {
      var m, props, ref;
      props = {};
      if (this.isProperties()) {
        while (m = propertyRE.exec(this.text.substring(this.contentPos, this.endPos))) {
          props[m[PROPERTY_KEY]] = ((ref = m[PROPERTY_VALUE]) != null ? ref : '').trim();
        }
      }
      return props;
    }

    //name: ->
    //  n = @leading().trim()
    //  n.substring 1, n.length - 1
    linkTo(node) {
      super.linkTo(node);
      if (this.isProperties()) {
        if (!(node instanceof Headline) && !(node instanceof Fragment)) {
          return console.log("WARNING: Drawer's parent is not a Headline'");
        } else {
          if (!node.properties) {
            node.properties = {};
          }
          return Object.assign(node.properties, this.properties());
        }
      }
    }

  };

  Drawer.prototype.type = 'drawer';

  return Drawer;

}).call(this);

export var Example = (function() {
  class Example extends Meat {
    constructor(text, offset, contentPos1, contentLength1) {
      super(text, offset);
      this.contentPos = contentPos1;
      this.contentLength = contentLength1;
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        contentPos: this.contentPos,
        contentLength: this.contentLength
      };
    }

    exampleText() {
      return this.text.substring(this.contentPos, this.contentPos + this.contentLength);
    }

  };

  Example.prototype.block = true;

  Example.prototype.type = 'example';

  return Example;

}).call(this);

export var Keyword = (function() {
  class Keyword extends Meat {
    constructor(text, offset, name1, info1) {
      super(text, offset);
      this.name = name1;
      this.info = info1;
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        name: this.name,
        info: this.info
      };
    }

    attributes() {
      return parseCodeAttributes(this.info);
    }

    lead() {
      return _(this.info.split(keywordPropertyRE)).first();
    }

  };

  Keyword.prototype.block = true;

  Keyword.prototype.type = 'keyword';

  return Keyword;

}).call(this);

export var parseCodeAttributes = function(attrText) {
  var attr, i, k, len, o, ref, v;
  o = _(attrText.split(keywordPropertyRE)).drop(1).map(function(str) {
    return str.trim();
  });
  if (o.isEmpty()) {
    return null;
  } else {
    attr = {};
    ref = o.chunk(2).toArray();
    for (i = 0, len = ref.length; i < len; i++) {
      [k, v] = ref[i];
      if (attr[k]) {
        if (!(attr[k] instanceof Array)) {
          attr[k] = [attr[k]];
        }
        attr[k].push(v);
      } else {
        attr[k] = v;
      }
    }
    return attr;
  }
};

export var Source = (function() {
  class Source extends Keyword {
    constructor(text, offset, name, info, infoPos1, content, contentPos1) {
      super(text, offset, name, info);
      this.infoPos = infoPos1;
      this.content = content;
      this.contentPos = contentPos1;
    }

    getLanguage() {
      var ref;
      return (ref = this.lead()) != null ? ref.trim().toLowerCase() : void 0;
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        name: this.name,
        info: this.info,
        infoPos: this.infoPos,
        content: this.content,
        contentPos: this.contentPos,
        contentLength: this.content.length
      };
    }

  };

  Source.prototype.type = 'source';

  return Source;

}).call(this);

export var HTML = (function() {
  class HTML extends Keyword {
    constructor(text, offset, name, contentPos1, contentLength1, info) {
      super(text, offset, name, info);
      this.contentPos = contentPos1;
      this.contentLength = contentLength1;
    }

    leading() {
      return this.text.substring(0, this.contentPos);
    }

    trailing() {
      return this.text.substring(this.contentPos + this.contentLength);
    }

    content() {
      return this.text.substring(this.contentPos, this.contentPos + this.contentLength);
    }

    jsonDef() {
      return {
        type: this.type,
        info: this.info || '',
        text: this.text,
        offset: this.offset,
        contentPos: this.contentPos,
        contentLength: this.contentLength
      };
    }

  };

  HTML.prototype.type = 'html';

  return HTML;

}).call(this);

export var Results = (function() {
  class Results extends Keyword {
    constructor(text, offset, name, contentPos1) {
      super(text, offset, name);
      this.contentPos = contentPos1;
    }

    content() {
      return this.text.substring(this.contentPos);
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        name: this.name,
        contentPos: this.contentPos
      };
    }

  };

  Results.prototype.type = 'results';

  return Results;

}).call(this);

export var AttrHtml = (function() {
  class AttrHtml extends Keyword {
    constructor(text, offset, name, contentPos1) {
      super(text, offset, name);
      this.contentPos = contentPos1;
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset,
        name: this.name,
        contentPos: this.contentPos
      };
    }

  };

  AttrHtml.prototype.type = 'attr';

  return AttrHtml;

}).call(this);

export var UnknownDeclaration = (function() {
  class UnknownDeclaration extends Meat {
    constructor(text, offset) {
      super(text, offset);
    }

    jsonDef() {
      return {
        type: this.type,
        text: this.text,
        offset: this.offset
      };
    }

  };

  UnknownDeclaration.prototype.type = 'unknown';

  return UnknownDeclaration;

}).call(this);

export var nextOrgNode = function(node) {
  var up;
  up = false;
  while (node) {
    if (node.children && !up && node.children.length) {
      return node.children[0];
    } else if (node.next) {
      return node.next;
    } else {
      up = true;
      node = node.parent;
    }
  }
  return null;
};


// Parse the content of an orgmode file

export var parseOrgMode = function(text, offset, useFragment) {
  var res, rest;
  if (text instanceof Node) {
    return text;
  } else {
    [res, rest] = parseHeadline('', offset != null ? offset : 0, 0, void 0, void 0, void 0, text, text.length);
    if (rest.length) {
      throw new Error(`Text left after parsing: ${rest}`);
    }
    if (useFragment) {
      if (res.children.length === 1) {
        res = res.children[0];
      } else if (res.children.length > 1) {
        res = new Fragment(res.offset, res.children);
      }
    }
    return res.linkNodes();
  }
};

parseHeadline = function(text, offset, level, todo, priority, tags, rest, totalLen) {
  var child, children, oldRest, originalRest;
  children = [];
  originalRest = rest;
  while (true) {
    oldRest = rest;
    [child, rest] = parseOrgChunk(rest, originalRest.length - rest.length + offset, level);
    if (!child) {
      break;
    }
    if (child.lowerThan(level)) {
      while (child) {
        children.push(child);
        child = child.next;
      }
    } else {
      rest = oldRest;
    }
  }
  return [new Headline(text, level, todo, priority, tags || '', children, offset), rest];
};

export var parseTags = function(text) {
  var i, len, ref, t, tagArray;
  tagArray = [];
  ref = (text ? text.split(':') : []);
  for (i = 0, len = ref.length; i < len; i++) {
    t = ref[i];
    if (t) {
      tagArray.push(t);
    }
  }
  return tagArray;
};

fullLine = function(match, text) {
  return text.substring(match.index, match.index + match[0].length + (text[match.index + match[0].length] === '\n' ? 1 : 0));
};

parseOrgChunk = function(text, offset, level) {
  var l, line, m, meat, meatLen, ref, simple;
  if (!text) {
    return [null, text];
  } else {
    m = text.match(headlineRE);
    simple = ((ref = text.match(simpleRE)) != null ? ref.index : void 0) === 0;
    if ((m != null ? m.index : void 0) === 0 && !simple) {
      if (m[HL_LEVEL].trim().length <= level) {
        return [null, text];
      } else {
        line = fullLine(m, text);
        return parseHeadline(line, offset, m[HL_LEVEL].trim().length, m[HL_TODO], m[HL_PRIORITY], m[HL_TAGS], text.substring(line.length), offset + text.length);
      }
    } else {
      if ((m != null ? m.index : void 0) === 0 && simple && (l = text.indexOf('\n')) > -1 && (m = text.substring(l).match(headlineRE))) {
        meatLen = m.index + l;
      } else {
        meatLen = m && (m.index > 0 || !simple) ? m.index : text.length;
      }
      meat = text.substring(0, meatLen);
      return parseMeat(meat, offset, text.substring(meatLen), false);
    }
  }
};

MeatParser = class MeatParser {
  constructor() {}

  checkPat(pattern, cont) {
    var line, match;
    if (!this.result && (match = this.meat.match(pattern))) {
      if (match.index === 0) {
        line = fullLine(match, this.meat);
        return this.result = cont(line, this.meat.substring(line.length) + this.rest, match);
      } else {
        return this.minLen = Math.min(this.minLen, match.index);
      }
    }
  }

  parse(meat, offset, rest, singleLine) {
    var m, meatText, newline;
    this.meat = meat;
    this.rest = rest;
    this.minLen = meat.length + offset;
    this.result = null;
    if (!this.singleLine) {
      this.checkPat(resultsRE, function(line, newRest) {
        return parseResults(line, offset, newRest);
      });
      this.checkPat(attrHtmlRE, function(line, newRest) {
        return parseAttr(line, offset, newRest);
      });
      this.checkPat(srcStartRE, function(line, newRest, srcStart) {
        return parseSrcBlock(line, offset, srcStart[SRC_INFO], srcStart[SRC_BOILERPLATE].length, newRest);
      });
      this.checkPat(htmlStartRE, function(line, newRest, html) {
        return parseHtmlBlock(line, offset, newRest, html);
      });
      this.checkPat(keywordRE, function(line, newRest, keyword) {
        return parseKeyword(keyword, line, offset, keyword[KW_NAME], keyword[KW_INFO], newRest);
      });
      this.checkPat(listRE, function(line, newRest, list) {
        var ref, ref1;
        return parseList(list, line, offset, (ref = (ref1 = list[LIST_LEVEL]) != null ? ref1.length : void 0) != null ? ref : 0, list[LIST_CHECK_VALUE], list[LIST_INFO], newRest);
      });
      this.checkPat(exampleStartRE, function(line, newRest, start) {
        var end;
        if ((end = newRest.match(declRE)) && end[0].match(exampleEndRE)) {
          return parseExample(line, offset, start, end, newRest);
        }
      });
      this.checkPat(drawerRE, function(line, newRest, drawer) {
        var end;
        if (end = newRest.match(endRE)) {
          return parseDrawer(line, drawer[DRAWER_NAME], offset, end, newRest);
        }
      });
      this.checkPat(declRE, function(line, newRest) {
        return parseUnknown(line, offset, newRest);
      });
    }
    if (this.result) {
      return this.result;
    } else {
      this.checkPat(simpleRE, function(line, newRest, simple) {
        var child, children, inside, insideOffset;
        inside = simple[0].substring(1, simple[0].length - 1);
        insideOffset = offset + 1;
        children = [];
        while (inside) {
          [child, inside] = parseMeat(inside, insideOffset, '', true);
          while (child) {
            children.push(child);
            insideOffset = child.offset + child.text.length;
            child = child.next;
          }
        }
        return new SimpleMarkup(simple[0], offset, children);
      });
      this.checkPat(linkRE, function(line, newRest, link) {
        var child, children, inside, insideOffset;
        inside = link[LINK_DESCRIPTION];
        insideOffset = offset + link[LINK_HEAD].length;
        children = [];
        while (inside) {
          [child, inside] = parseMeat(inside, insideOffset, '', true);
          while (child) {
            children.push(child);
            insideOffset = child.offset + child.text.length;
            child = child.next;
          }
        }
        return new Link(link[0], offset, link[LINK_INFO], children);
      });
      if (!this.result) {
        if (newline = meat.substring(0, 2) === '\n\n') {
          meatText = meat.substring(2);
        }
        meatText = meat.substring(0, this.minLen);
        if (m = meatText.match(lineBreakPat)) {
          meatText = meat.substring(0, m.index);
        }
        if (newline) {
          meatText = '\n\n' + meatText;
        }
        this.result = new Meat(meatText, offset);
      }
      return parseRestOfMeat(this.result, meat.substring(this.result.text.length), rest);
    }
  }

};

lineBreakPat = /\n\n/;

export var parseMeat = function(meat, offset, rest, singleLine) {
  return new MeatParser().parse(meat, offset, rest, singleLine);
};

parseRestOfMeat = function(node, meat, rest) {
  var node2;
  if (meat && node.text[node.text.length - 1] !== '\n') {
    [node2, rest] = parseMeat(meat, node.offset + node.allText().length, rest, true);
    node.next = node2;
    return [node, rest];
  } else {
    return [node, meat + rest];
  }
};

parseResults = function(text, offset, rest) {
  var lines, m, oldRest, ref;
  oldRest = rest;
  while (m = rest.match(resultsLineRE)) {
    rest = rest.substring(m[0].length);
  }
  if (oldRest === rest && rest.length && !((ref = rest[0]) === '#' || ref === '\n')) {
    rest = rest.substring(((m = rest.match(/\n/)) ? m.index + 1 : rest.length));
  }
  lines = oldRest.substring(0, oldRest.length - rest.length);
  return [new Results(text + lines, offset, text.match(resultsRE)[RES_NAME], text.length), rest];
};

parseAttr = function(text, offset, rest) {
  var lines, m, oldRest;
  oldRest = rest;
  while (m = rest.match(attrHrmlLineRE)) {
    rest = rest.substring(m[0].length);
  }
  lines = oldRest.substring(0, oldRest.length - rest.length);
  return [new AttrHtml(text + lines, offset, text.match(attrHtmlRE)[ATTR_NAME], text.length), rest];
};

parseDrawer = function(text, name, offset, end, rest) {
  var pos;
  pos = end.index + (fullLine(end, rest)).length;
  return [new Drawer(text + rest.substring(0, pos), offset, name, text.length, text.length + end.index), rest.substring(pos)];
};

parseKeyword = function(match, text, offset, name, info, rest) {
  return [new Keyword(text, offset, name, text.substring(match[KW_BOILERPLATE].length)), rest];
};

parseExample = function(startLine, offset, start, end, rest) {
  var contentLength, contentPos, lastLine, newRest, text;
  lastLine = fullLine(end, rest);
  newRest = rest.substring(end.index + lastLine.length);
  contentPos = startLine.length;
  contentLength = end.index;
  text = startLine + rest.substring(0, rest.length - newRest.length);
  return [new Example(text, offset, contentPos, contentLength), newRest];
};

parseSrcBlock = function(text, offset, info, infoPos, rest) {
  var end, endLine, line, otherSrcStart;
  end = rest.match(srcEndRE);
  otherSrcStart = rest.match(srcStartRE);
  if (!end || (otherSrcStart && otherSrcStart.index < end.index)) {
    line = text.match(/^.*\n/);
    if (!line) {
      line = [text];
    }
    return [new Meat(line[0]), text.substring(line[0].length) + rest];
  } else {
    endLine = fullLine(end, rest);
    return [new Source(text + rest.substring(0, end.index + endLine.length), offset, text.match(srcStartRE)[SRC_NAME], info, infoPos, rest.substring(0, end.index), text.length), rest.substring(end.index + endLine.length)];
  }
};

parseHtmlBlock = function(text, offset, rest, match) {
  var end, endLine, line, otherHtmlStart;
  end = rest.match(htmlEndRE);
  otherHtmlStart = rest.match(htmlStartRE);
  line = text.match(/^.*\n/);
  if (!line) {
    line = [text];
  }
  if (!end || (otherHtmlStart && otherHtmlStart.index < end.index)) {
    return [new Meat(line[0]), text.substring(line[0].length) + rest];
  } else {
    endLine = fullLine(end, rest);
    return [new HTML(text + rest.substring(0, end.index + endLine.length), offset, match[HTML_START_NAME], line[0].length, text.length + end.index - line[0].length, match[HTML_INFO]), rest.substring(end.index + endLine.length)];
  }
};

parseList = function(match, text, offset, level, check, info, rest) {
  var children, contentOffset, inside, insideOffset, node;
  contentOffset = listContentOffset(match);
  insideOffset = offset + contentOffset;
  inside = text.substring(contentOffset);
  children = [];
  while (inside) {
    [node, inside] = parseMeat(inside, insideOffset, '', true);
    while (node) {
      children.push(node);
      insideOffset += node.allText().length;
      node = node.next;
    }
  }
  return [new ListItem(text, offset, level, check === 'X' || (check === ' ' ? false : null), contentOffset, children), rest];
};

parseUnknown = function(line, offset, rest) {
  return [new UnknownDeclaration(line, offset), rest];
};

listContentOffset = function(match) {
  var ref, ref1;
  return match[LIST_LEVEL].length + match[LIST_BOILERPLATE].length + ((ref = (ref1 = match[LIST_CHECK]) != null ? ref1.length : void 0) != null ? ref : 0);
};

markupText = function(text) {
  return {};
};

//parseOrgMode
//parseMeat
//Node
//Headline
//Fragment
//Meat
//Keyword
//Source
//HTML
//Results
//resultsRE
//ListItem
//SimpleMarkup
//Link
//UnknownDeclaration
//Drawer
//Example
//drawerRE
//headlineRE
//HL_LEVEL
//HL_TODO
//HL_PRIORITY
//HL_TEXT
//HL_TAGS
//parseTags
//matchLine
//keywordRE
//KW_BOILERPLATE
//KW_NAME
//KW_INFO
//srcStartRE
//SRC_BOILERPLATE
//SRC_INFO
//nextOrgNode
//AttrHtml
//parseCodeAttributes

//# sourceMappingURL=org.js.map
